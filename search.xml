<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue2源码：diff 算法原理</title>
      <link href="/2023/07/12/Vue2%E6%BA%90%E7%A0%81%EF%BC%9Adiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/12/Vue2%E6%BA%90%E7%A0%81%EF%BC%9Adiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h1><p>如果我现在修改了模板中的一个属性</p><p>那么 Vue 怎么更新渲染处理比较好呢？</p><ul><li>把旧的 DOM 全部删除，然后渲染一个新的 DOM 替换上去？</li></ul><p>这样显然成本比较高</p><p>为了节省开销，Vue 中会<strong>将新老虚拟DOM进行对比，尽量复用旧 DOM</strong></p><p>这个过程就是 diff 算法</p><p>下面我们按照这个思路图，进行讲解</p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/流程图.png" style="height: 450px; width: 900px;"></div><h1 id="2-patch"><a href="#2-patch" class="headerlink" title="2 patch()"></a>2 patch()</h1><blockquote><p>源码位置：vue-main\src\core\vdom\patch.ts</p></blockquote><p>当数据更新，数据劫持，触发setter，派发更新，然后会执行 <strong>patch()</strong> 方法，会传入参数：<strong>老的虚拟节点、新的虚拟节点</strong></p><p>首先，这里面会执行 <strong>sameVnode()</strong> ，判断当前两个节点<strong>是否是同类标签</strong></p><ul><li>不是同类标签：那就直接替换就完事了</li><li>是同类标签：就要进行进一步比较，看看他俩是不是完全一样的，调用 <strong>patchVnode()</strong> 方法</li></ul><h2 id="2-1-sameVnode-是否是同类标签"><a href="#2-1-sameVnode-是否是同类标签" class="headerlink" title="2.1 sameVnode() 是否是同类标签"></a>2.1 sameVnode() 是否是同类标签</h2><p> sameVnode() 的作用是：通过对比 key、tag、inputType 判断当前两个节点是否是同类标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp;</span><br><span class="line">    ((a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">      a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">sameInputType</span>(a, b)) ||</span><br><span class="line">      (<span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp; <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-patchVnode"><a href="#3-patchVnode" class="headerlink" title="3 patchVnode()"></a>3 patchVnode()</h1><ul><li>文本不同则覆盖文本</li><li>旧虚拟 DOM 多余子节点，则删除；</li><li>旧虚拟 DOM 少子节点，则新增</li><li>都有子节点，进行 updateChildren() 比较两个人的子节点</li></ul><h1 id="4-updateChildren-diff-核心方法"><a href="#4-updateChildren-diff-核心方法" class="headerlink" title="4 updateChildren() - diff 核心方法"></a>4 updateChildren() - diff 核心方法</h1><p><code>updateChildren</code> 是核心，采用双指针的方式，比较<strong>旧虚拟 DOM</strong> 和<strong>新虚拟 DOM</strong> 的<strong>子节点</strong>，尽量复用旧虚拟 DOM </p><p><strong>while 循环：</strong></p><p>因为循环过程中有<strong>两个指针</strong>指向新、旧DOM，因此while循环条件是当前遍历的index没有越界</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx)</span><br></pre></td></tr></table></figure><p><strong>头头比较：</strong></p><ul><li>指针指向：<strong>oldStartVnode, newStartVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>index++</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/头头比较.png" style="height: 550px; width: 600px;"></div><p><strong>尾尾比较：</strong></p><ul><li>指针指向：<strong>oldEndVnode, newEndVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>index - -</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/尾尾比较.png" style="height: 550px; width: 760px;"></div><p><strong>头尾比较：</strong></p><ul><li>指针指向：<strong>oldStartVnode, newEndVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>旧节点 index++   新节点 index–</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/头尾比较.png" style="height: 350px; width: 760px;"></div><p><strong>尾头比较：</strong></p><ul><li>指针指向：<strong>oldEndVnode, newStartVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>旧节点 index–   新节点 index++</li></ul><p><strong>乱序比较：</strong></p><p>根据老的索引和key做一个映射关系 </p><p>根据新虚拟节点的去寻找</p><p>找到则移动到前面（移动过的标识为undefined）</p><p>找不到则添加</p><p>最后多余的就删除</p><p><strong>跳出while循环</strong></p><p>如果旧节点没有，新节点有</p><p>就要把多余的节点就插入到老的</p><p>那么这里有两种情况：</p><ul><li>头头比较，可以直接把<strong>多余的节点插入 old节点 后面</strong>   </li><li>尾尾比较：需要把<strong>多余的节点插入 old节点 前面</strong></li></ul><p>一个要插入前面、一个要插入后面，所以 Vue 中使用<strong>获取下一个元素方法</strong>来解决：</p><ul><li>拿到这个多余节点的<strong>下一个元素</strong>，可能为空(头头比较情况)，可能存在(尾尾比较情况)</li><li>执行 el.insertBefore(真实节点, 下一个元素)  <ul><li>如果下一个元素为空：就是<strong>头头比较</strong>的情况，则相当于appendChild() ，在<strong>老节点后面追加</strong>多余的节点</li><li>如果不为空：就是<strong>尾尾比较</strong>情况，在老节点中找到<strong>此下一个元素</strong>，要到会把多余节点<strong>插入到下一个元素的前面</strong></li></ul></li></ul><p>至此 diff 算法完成</p><p><strong>不过这里还涉及到一个面试题</strong></p><h1 id="5-面试题"><a href="#5-面试题" class="headerlink" title="5 面试题"></a>5 面试题</h1><h3 id="5-1-面试题：为什么v-for循环时，key不能使用索引？"><a href="#5-1-面试题：为什么v-for循环时，key不能使用索引？" class="headerlink" title="5.1 面试题：为什么v-for循环时，key不能使用索引？"></a>5.1 面试题：为什么v-for循环时，key不能使用索引？</h3><p>如下图，如果当前有一个数组存储：[‘苹果’, ‘梨’, ‘香蕉’]</p><p>使用 v-for 循环，渲染到页面上</p><p>并将苹果置为<strong>被勾选状态</strong></p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/面试题1.png" style="height: 250px; width: 500px;"></div><p><strong>如果现在使用 索引 作为 key</strong></p><p>用户向数组中 unshift 一个火龙果</p><p>那么界面，就变成了火龙果被勾选的状态</p><p>这是为什么？？</p><h3 id="5-2-原因"><a href="#5-2-原因" class="headerlink" title="5.2 原因"></a>5.2 原因</h3><p>因为修改数据后，虚拟DOM转换为真实DOM过程的 diff 算法</p><p>sameVnode() 采用 key、tag、inputType 判断是否是同类标签</p><p>之前苹果的索引为0</p><p>插入火龙果后，火龙果的索引依然是0</p><p>此时 sameVnode() 判断两个节点是同类标签，进一步比较 patchVnode()，<strong>仅使用新文本替换旧文本</strong></p><p>勾选状态还在</p><p>所以火龙果就被勾选了</p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/面试题2.png" style="height: 750px; width: 760px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码：依赖收集 派发更新</title>
      <link href="/2023/07/11/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0/"/>
      <url>/2023/07/11/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-What"><a href="#1-What" class="headerlink" title="1 What"></a>1 What</h1><p>程序在运行时，状态会不断发生变化。当状态发生变化后，需要重新渲染，得到最新的视图。</p><p>正是<strong>响应式</strong>赋予了<strong>状态变更 - 重新渲染</strong>的能力</p><p>通常来说，响应式的核心组成部分为：<strong>数据劫持、依赖收集、派发更新</strong></p><p>之前一篇文章已经叙述过数据劫持的内容</p><blockquote><p>数据劫持源码分析：<a href="https://icheng.github.io/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/">https://icheng.github.io/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/</a></p></blockquote><p>下面来分析一下依赖收集、派发更新的源码原理</p><h1 id="2-思考-3-个问题"><a href="#2-思考-3-个问题" class="headerlink" title="2 思考 3 个问题"></a>2 思考 3 个问题</h1><p>我们知道了 Vue2 底层是通过 <code>Object.defineProperty</code> 来实现数据响应式的，但是单有这个还不够，因为数据可能没有在模板中使用</p><p>所以 Vue2，通过<strong>依赖收集</strong>来判断哪些用到的数据的变更需要触发视图更新，再通过<strong>派发更新</strong>通知视图进行更新渲染</p><p><strong>那么我们先来考虑 3 个问题：</strong></p><ul><li>依赖是谁？换句话说，属性发生变化后，通知到谁？（Watcher）</li><li>依赖收集到哪里？每一个数据的依赖都需要集中管理（Dep）</li><li>在哪里做依赖收集？（Observe）</li></ul><h2 id="3-依赖收集中的各个类"><a href="#3-依赖收集中的各个类" class="headerlink" title="3 依赖收集中的各个类"></a>3 依赖收集中的各个类</h2><p>先来看一张图</p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/依赖收集1.jpg" style="height: 450px; width: 900px;"></div><p>数据是<strong>被观察者</strong>，将数据标记为已观测数据后，数据就会有一个 Dep 实例</p><p>触发数据的 getter 时，就会进行依赖收集，将依赖集中管理</p><p>触发数据的 setter 时，就会进行派发更新，会通知 <strong>观察者Watcher</strong> 进行渲染更新</p><p>带着这张图，我们来分析一下过程中的 3 个类： Watcher、Dep、Observe</p><h2 id="3-1-Dep"><a href="#3-1-Dep" class="headerlink" title="3.1 Dep"></a>3.1 Dep</h2><blockquote><p>源码位置：vue-main\src\core\observer\dep.ts</p></blockquote><p>每一个被观测的数据都会有一个 <code>Dep</code> 类实例，且 Dep 拥有一个唯一 id</p><h4 id="subs-队列"><a href="#subs-队列" class="headerlink" title="subs 队列"></a>subs 队列</h4><p>Dep 内部维护一个 <strong>subs</strong> 队列</p><p>subs就是subscribers的意思，保存着依赖本数据的<strong>观察者 Watcher</strong></p><h4 id="Dep-target"><a href="#Dep-target" class="headerlink" title="Dep.target"></a>Dep.target</h4><p>全局变量，指向目前正在使用的 watcher</p><ul><li><strong>targetStack</strong>：栈结构，用来保存Watcher</li><li><strong>pushTarget</strong>：往 targetStack 中 push 当前的 Watcher（排在前一个Watcher的后面），并把  Dep.target  赋值给当前 Watcher</li><li><strong>popTarget</strong>：先把 targetStack 最后一个元素弹出(.pop)，再把 Dep.target 赋值给最后一个Watcher(也就是还原了前一个Watcher)</li><li>通过上述实现，vue 保证了 全局唯一的 Watcher，准确赋值在 Dep.target 中</li></ul><h4 id="dep-depend"><a href="#dep-depend" class="headerlink" title="dep.depend()"></a>dep.depend()</h4><p>Dep 类中有个一个 depend() 方法，进行<strong>依赖收集</strong></p><p>但他不会直接将 watcher 存放在 subs 中</p><p>而是调用 <code>Dep.target.addDep()</code> ：</p><p>通知 watcher 先存放 dep （去重）</p><p>再调用 <code>dep.addSub()</code> 让 dep 存储该 watcher</p><p><strong>这样便完成了双向存储，并且不会重复存储</strong></p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/dep1.png" style="height: 230px; width: 300px;"></div><h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify()"></a>dep.notify()</h4><p>触发数据劫持的 setter 时会执行这个 dep.notify() </p><p>会遍历 subs</p><p>通知 watcher 执行  <code>.update()</code> 方法 去<strong>派发更新</strong></p><h2 id="3-2-Watcher"><a href="#3-2-Watcher" class="headerlink" title="3.2 Watcher"></a>3.2 Watcher</h2><p>观察者，拥有一个唯一id</p><p>同时要注意的是，watcher有三种：render watcher、 computed watcher (lazy为true)、user watcher (user为true)</p><h4 id="addDep"><a href="#addDep" class="headerlink" title="addDep()"></a>addDep()</h4><p>这个方法上面说过了，用来双向存储</p><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><p>派发更新</p><p>这里会进行判断：</p><p>如果 lazy 为 true，说明是计算属性，则将 dirty 设置为 true</p><p>或者就进行执行 <code>queueWatcher</code> 进行异步更新</p><blockquote><p>异步更新文章：</p><p><a href="https://icheng.github.io/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/">https://icheng.github.io/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/</a></p></blockquote><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>update() 后，进入异步更新，异步更新的 flushSchedulerQueue() 还是会执行这个get()方法</p><ul><li>调用dep的pushTarget</li><li>调用回调函数（如渲染更新方法 <code>vm._update(vm._render())</code> ）</li><li>popTarget</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)  <span class="comment">// 调用函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Observe-依赖收集的入口"><a href="#3-3-Observe-依赖收集的入口" class="headerlink" title="3.3 Observe 依赖收集的入口"></a>3.3 Observe 依赖收集的入口</h2><p>之前的文章讲过，Observer 会将数据标记<strong>已观测数据</strong></p><p>并通过 Object.defineProperty 的 get&#x2F;set 劫持数据的读取和修改</p><p>劫持数据 <code>getter</code> 时进行<strong>依赖收集</strong>，如果 <code>Dep.target</code> 存在，就调用 <code>dep.depend()</code></p><p>劫持数据 <code>setter</code> 时<strong>派发更新</strong>，调用 <code>dep.notify()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;</span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getter) &#123;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shallow &amp;&amp; <span class="title function_">isRef</span>(value) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newVal</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal, <span class="literal">false</span>, mock)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">          <span class="attr">target</span>: obj,</span><br><span class="line">          key,</span><br><span class="line">          <span class="attr">newValue</span>: newVal,</span><br><span class="line">          <span class="attr">oldValue</span>: value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到这里，是否细节太多绕晕了？</p><p><strong>来个初始化时的整体流程，从宏观角度再过一遍</strong></p><h1 id="3-初始化流程"><a href="#3-初始化流程" class="headerlink" title="3 初始化流程"></a>3 初始化流程</h1><p>比如我们在模板中使用 <code>&#123;&#123;name&#125;&#125;</code></p><p>组件挂载过程中，进行 new Watcher，创建一个渲染watcher</p><p>并传入参数：渲染更新方法 <code>vm._update(vm._render())</code></p><blockquote><p>源码位置：vue-main\src\core\instance\lifecycle.ts  （mountComponent）</p></blockquote><p>因为不是 computed  watcher ，会默认执行 get() 方法：</p><ul><li><p>pushTarget() ：当前 Dep.target 指向这个渲染watcher</p></li><li><p>调用回调函数，当前函数是渲染更新方法 <code>vm._update(vm._render())</code></p><p>首先 <code>vm._render()</code> 会去实例中取新值，这个过程则调用 <code>Object.defineProperty</code> 的 get，当前 <code>Dep.target</code> 是存在的，会执行 <code>dep.depend()</code> ，进行<strong>依赖收集</strong></p><p>那么 dep 和 watcher 的双向存储就完成了</p><p>然后 <code>vm._update()</code> 会将虚拟DOM转为真实DOM，涉及diff算法等等，总之渲染完成</p></li><li><p>popTarget()： Dep.target 不需要指向这个渲染watcher了</p></li><li><p>同时会存储目前的属性值，存储在value，方便后面判断值是否修改了</p></li></ul><p>看看源码：</p><blockquote><p>源码位置：vue-main\src\core\observer\watcher.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="literal">undefined</span> : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/初始化流程.png" style="height: 230px; width: 580px;"></div><h1 id="4-修改值流程"><a href="#4-修改值流程" class="headerlink" title="4 修改值流程"></a>4 修改值流程</h1><p>那么修改值的过程，主要就是多了劫持getter和异步更新</p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/修改值流程.png" style="height: 530px; width: 880px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码：数据劫持原理</title>
      <link href="/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据劫持是什么"><a href="#1-数据劫持是什么" class="headerlink" title="1 数据劫持是什么"></a>1 数据劫持是什么</h1><p>Vue 最独特的特性之一，是其响应式系统。</p><p>而实现响应式的过程中，要实现<strong>数据劫持</strong>才能监听数据的变化</p><p>数据劫持就是：拦截属性的读取和修改，简单来说就是数据的任何变化都要能监测到，这样才能根据数据变化做对应操作</p><h1 id="2-数据劫持源码逻辑"><a href="#2-数据劫持源码逻辑" class="headerlink" title="2 数据劫持源码逻辑"></a>2 数据劫持源码逻辑</h1><h2 id="2-1-initState-初始化"><a href="#2-1-initState-初始化" class="headerlink" title="2.1 initState() 初始化"></a>2.1 initState() 初始化</h2><p>Vue 在执行完生命周期钩子函数 <code>beforeCreate</code> 之后，会根据配置项是否存在，执行对应的相应的初始化（如Props、methods、data、computed等等）</p><p><strong>如果 data 存在</strong></p><p>会执行 <code>initData()</code>，进行 data 数据初始化操作</p><p>下面进行 <code>initData()</code> 初始化的分析</p><p>这里的源码：</p><blockquote><p>vue-main\src\core\instance\state.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Composition API</span></span><br><span class="line">  <span class="title function_">initSetup</span>(vm)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  data 数据初始化</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="title function_">observe</span>((vm.<span class="property">_data</span> = &#123;&#125;))</span><br><span class="line">    ob &amp;&amp; ob.<span class="property">vmCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-initData-数据初始化"><a href="#2-2-initData-数据初始化" class="headerlink" title="2.2 initData()  数据初始化"></a>2.2 initData()  数据初始化</h2><p>进入 <code>initData()</code> ，<strong>主要做了 3 件事：</strong></p><p>1 首先就是<strong>判断 data 的类型</strong></p><ul><li>如果 data 是函数，就调用这个函数，返回数据</li><li>如果是对象，就可以使用这个对象</li></ul><blockquote><p>当然，我们知道 data 还是希望写成函数类型的：</p><p>因为数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，拥有自己的<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据</p><p>我们组件的date单纯的写成对象形式，这些实例用的是同一个构造函数，由于JavaScript的特性所导致，所有的组件实例共用了一个data，就会造成该组件的数据会被其他组件应影响</p></blockquote><p>2 如果methods、props 和 data 中没有重名的属性，就用 <strong>proxy 代理 data 中的属性到 vm 上</strong></p><p>即： <code>vm.name -&gt; vm._data.name</code></p><p>3 调用 <strong>observe() 进行数据劫持</strong>，这里就是数据劫持真正的开始</p><p>这部分的源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">data</span>: any = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="title function_">isFunction</span>(data) ? <span class="title function_">getData</span>(data, vm) : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="keyword">const</span> ob = <span class="title function_">observe</span>(data)</span><br><span class="line">  ob &amp;&amp; ob.<span class="property">vmCount</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-observe"><a href="#2-3-observe" class="headerlink" title="2.3 observe()"></a>2.3 observe()</h2><p>这里主要做一些规范处理。接下来主要列一些什么情况下数据会被标记为响应式，什么情况下不被响应式</p><ul><li>如果不是数组&#x2F;对象，则return，不继续执行；</li><li>如果该数据是 <code>Observer</code> 类的实例，则意味着当前属性已被标记为响应式数据，无需处理</li><li>return new Observer() 将其标记为响应式数据</li></ul><p>这部分的源码：</p><blockquote><p>vue-main\src\core\observer\index.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  ssrMockReactivity?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">__ob__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    (ssrMockReactivity || !<span class="title function_">isServerRendering</span>()) &amp;&amp;</span><br><span class="line">    (<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">__v_skip</span> <span class="comment">/* ReactiveFlags.SKIP */</span> &amp;&amp;</span><br><span class="line">    !<span class="title function_">isRef</span>(value) &amp;&amp;</span><br><span class="line">    !(value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value, shallow, ssrMockReactivity)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-Observer类"><a href="#2-4-Observer类" class="headerlink" title="2.4 Observer类"></a>2.4 Observer类</h2><p><code>Observer</code> 构造函数会真正的将数据标记为响应式</p><ul><li><p>首先给属性增加一个<strong>不可枚举的 <code>__ob__</code> 对象</strong> ，表明<strong>已被观测</strong> (为啥要不可枚举？为了不影响实际开发，比如 <code>for..in..</code> 循环的时候不遍历到 <code>__ob__</code> 属性)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)      <span class="comment">//给属性增加一个**不可枚举的 `__ob__` 对象**</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是判断当前属性<strong>是数组还是对象</strong></p></li></ul><h3 id="2-4-1-如果是数组"><a href="#2-4-1-如果是数组" class="headerlink" title="2.4.1 如果是数组"></a>2.4.1 如果是数组</h3><h6 id="先对数组的每一项进行监测"><a href="#先对数组的每一项进行监测" class="headerlink" title="先对数组的每一项进行监测"></a>先对数组的每一项进行监测</h6><p><strong>调用 observeArray()</strong> ，遍历数组，对每一元素调用 <code>observe()</code> 方法继续监测数据</p><p>这里的源码：</p><blockquote><p>vue-main\src\core\observer\index.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">observeArray</span>(<span class="params">value: any[]</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(value[i], <span class="literal">false</span>, <span class="variable language_">this</span>.<span class="property">mock</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="拦截数组方法"><a href="#拦截数组方法" class="headerlink" title="拦截数组方法"></a>拦截数组方法</h6><blockquote><p>有些方法会修改数组本身，这些方法被称为<strong>变异方法</strong> （push、pop、shift、unshift、splice、sort、reverse）</p><p>当开发者调用这些方法修改<code>data</code>中的数组数据的时候，<code>Vue</code>需要及时得知并作出反应</p></blockquote><ul><li>首先，拿到数组的原型链<code>Array.prototype</code>，通过<code>Object.create</code> 复制一份</li></ul><blockquote><p>因为需要在数组原型上修改7个方法，但是直接修改会干掉原有的方法，我们需要用 <code>Object.create()</code> 拷贝一份数组原型出来，在复制出来的原型上面做功能扩展</p></blockquote><ul><li>然后，会调用原生数组方法（毕竟不能影响数组原本的功能）</li><li>关键在于代码中间部分，他会调用 <code>__ob__.dep</code> 的 <code>notify </code>方法去通知它的watcher，告诉对方：我有变化了，你快更新吧；</li><li>如果是能增加数组长度的 3 个方法 <code>push、unshift、splice</code> ，获取到插入的值，然后把新添加的值变成一个响应式对象（再次调用observeArray()）。</li></ul><p>这里的源码：</p><blockquote><p>vue-main\src\core\observer\array.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]  </span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)   <span class="comment">// 调用原生数组方法</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      ob.<span class="property">dep</span>.<span class="title function_">notify</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">ARRAY_MUTATION</span>,</span><br><span class="line">        <span class="attr">target</span>: <span class="variable language_">this</span>,</span><br><span class="line">        <span class="attr">key</span>: method</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-2-如果是对象"><a href="#2-4-2-如果是对象" class="headerlink" title="2.4.2 如果是对象"></a>2.4.2 如果是对象</h3><p>遍历对象的每个元素，执行 <code>defineReactive()</code> 方法逻辑如下:</p><p>首先 new Dep()，该 dep 在后面 get set 时都会使用这个<strong>闭包产生的 dep</strong>，这个时候就能明白了数据对象中每个数据字段都有属于自己的 <code>dep</code> 常量（这里涉及到依赖收集理念）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br></pre></td></tr></table></figure><p>接下来缓存原有描述属性中可能存在的 <code>get</code> 方法和 <code>set</code> 方法，分别缓存在变量 <code>getter</code>、<code>setter </code>中，为什么要缓存呢？主要是接下来会执行<code>Object.defineProperty  </code> 重新定义属性的 <code>getter/setter</code>，这会导致原有的 <code>get</code>、<code>set</code> 方法被重新覆盖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line"><span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br></pre></td></tr></table></figure><p>然后，默认会将对象进行深度劫持</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">observe</span>()</span><br></pre></td></tr></table></figure><p><strong>接下来我们看看拦截器的 <code>get</code> 方法都做了些啥：</strong></p><p>因为是读取属性，首先要确保不能影响正常逻辑，要调用前面缓存的 <code>getter</code>，拿到正确的返回结果</p><p>然后就是 <code>getter</code> 的主要使命，收集依赖：</p><p>若 <code>Dep.target</code> 存在，则执行<code>dep.depend()</code>。那么 <code>Dep.target</code> 是什么？其实就是 watcher</p><p>（依赖收集内容放到后面的文章讲）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val     <span class="comment">// 拿到正确的返回结果</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;      <span class="comment">//依赖收集</span></span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><strong>接下来我们看看拦截器的<code>set</code>方法都做了些啥：</strong></p><p><code>set </code> 函数主要做两件事:</p><ul><li><p>如果值改变了，调用缓存的 setter，为属性设置新值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setter.<span class="title function_">call</span>(obj, newVal)</span><br></pre></td></tr></table></figure></li><li><p>通知 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.<span class="property">notify</span></span><br></pre></td></tr></table></figure></li></ul><p>这便是数据劫持的主要内容</p><p>想要理解它，还需要知道依赖收集中的 watcher、dep关系</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 JS 扩展 Markdown 语法</title>
      <link href="/2023/07/09/%E4%BD%BF%E7%94%A8%20JS%20%E6%89%A9%E5%B1%95%20Markdown%20%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/07/09/%E4%BD%BF%E7%94%A8%20JS%20%E6%89%A9%E5%B1%95%20Markdown%20%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>近期在使用 Hexo </p><p>用 Markdown 语法过程中</p><p>发现 Markdown 的原生语法<strong>无法设置图片的大小</strong></p><p>如官方推荐的引入图片方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>无法设置图片大小，并且图片会默认靠左边</p><p>如果想要实现图片 <strong>水平居中 + 调节大小</strong></p><p>好像只能通过写 HTML + CSS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;XXX.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 500px; width: 600px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>怪麻烦的</p><p><strong>于是我用  JS 扩展了 Markdown 语法，通过更简单的方式实现图片的放大缩小 + 水平居中</strong></p><p>可以在 GIthub 上下载源码：</p><p><a href="https://github.com/iCheng/hexo_relayout_image">https://github.com/iCheng/hexo_relayout_image</a></p><h1 id="2-使用语法"><a href="#2-使用语法" class="headerlink" title="2 使用语法"></a>2 使用语法</h1><h2 id="2-1-GIthub-上下载源码后"><a href="#2-1-GIthub-上下载源码后" class="headerlink" title="2.1 GIthub 上下载源码后"></a>2.1 GIthub 上下载源码后</h2><p>将 hexo_relayout_image.js 文件移动至 public&#x2F;js&#x2F; 下</p><h2 id="2-2-增加-script-脚本"><a href="#2-2-增加-script-脚本" class="headerlink" title="2.2 增加 script 脚本"></a>2.2 增加 script 脚本</h2><p>进入你的主题下 layout 目录中的 layout.ejs 文件</p><blockquote><p>我用的主题是Cupertino：路径就是 &#x2F;themes&#x2F;Cupertino&#x2F;layout&#x2F;layout.ejs</p></blockquote><p>将下面的代码加入到 body 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扩展语法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%- config.root %&gt;js/hexo_relayout_image.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/07/09/使用 JS 扩展 Markdown 语法/脚本文件.png" style="height: 70px; width: 700px;"></div><h2 id="2-3-使用语法"><a href="#2-3-使用语法" class="headerlink" title="2.3 使用语法"></a>2.3 使用语法</h2><blockquote><p>Hexo 内部会将 <code>![](image.jpg)</code> 转为 <code>img</code> 标签格式</p><p>官网：<code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p></blockquote><p>我的扩充的语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="variable constant_">XXXX</span>.<span class="property">png</span>?<span class="number">700</span>&amp;<span class="number">500</span>)</span><br></pre></td></tr></table></figure><ul><li>在路径后使用 <strong>?</strong> 分隔</li><li>然后输入宽(width)、高(height)，并使用 <strong>&amp;</strong> 连接</li></ul><p>然后：</p><p>该图片将 <strong>按照设置的宽(width)、高(height)</strong> 重绘</p><p>并且该图片会 <strong>自动实现水平居中</strong></p><h1 id="3-效果"><a href="#3-效果" class="headerlink" title="3 效果"></a>3 效果</h1><p><img src="/%E6%95%88%E6%9E%9C.png?500&500"></p>]]></content>
      
      
      <categories>
          
          <category> 一点小想法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码：nextTick原理</title>
      <link href="/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>nexttick源码</p><p>[TOC]</p><h1 id="1-nextTick-是什么"><a href="#1-nextTick-是什么" class="headerlink" title="1 nextTick 是什么"></a>1 nextTick 是什么</h1><p>由于 vue 中 DOM更新 是异步的</p><p>当你设置 <code>vm.someData = &#39;new value&#39;</code>，该数据不会立即重新渲染。</p><p>多数情况我们不需要关心这个过程，但是如果你要<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong>，就需要 nextTick 保证你的逻辑执行在<strong>完成更新 DOM之后</strong>了。</p><h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h1><h2 id="2-1-两个数组"><a href="#2-1-两个数组" class="headerlink" title="2.1 两个数组"></a>2.1 两个数组</h2><p>为了实现 nextTick，Vue中维护了2个数组：</p><ul><li>queue</li><li>callbacks</li></ul><h6 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h6><p>存放 wacther（去重），，当执行DOM更新的函数时，会遍历 queue 的元素 通知 watcher 去更新渲染</p><h6 id="callbacks"><a href="#callbacks" class="headerlink" title="callbacks"></a>callbacks</h6><p>存放回调函数(更新渲染任务、用户定义的逻辑)，当依次执行 callbacks 中维护的任务时，就可以保证用户<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong></p><p>先了解这两个数组，便于下面的原理分析</p><h2 id="2-2-修改数据时"><a href="#2-2-修改数据时" class="headerlink" title="2.2 修改数据时"></a>2.2 修改数据时</h2><p>当你设置 <code>vm.someData = &#39;new value&#39;</code></p><p>对应的依赖发生改变，Wacther会开始异步更新，调用 <code>queueWatcher()</code>函数</p><blockquote><p><code>queueWatcher()</code>函数源码位置：vue-main\src\core\observer\scheduler.ts</p></blockquote><p> <code>queueWatcher()</code>函数</p><p>首先判断 <code>queue</code> 数组中是否存在该 watcher ，如果不存在就会将当前 watcher 推入 <code>queue</code> 中，实现去重</p><blockquote><p>那么为什么要实现去重？</p><p>因为用户在一个组件中可能多次修改数据，<code>vm.someData = &#39;new value1&#39;， vm.someData = &#39;new value22&#39;</code></p><p>它不需要存放相同的 watcher，只需维护一个，等待 watcher 更新时会渲染最新的数据</p></blockquote><p>然后会调用 <code>nextTick()</code> 函数，并将回调函数 <code>flushSchedulerQueue()</code> 作为参数传入</p><p>总结一下：</p><ul><li>去重，watcher 推入 queue</li><li>调用 <code>nextTick()</code> 函数，并传入回调函数</li></ul><p>下面我们可以看看源代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueWatcher</span>(<span class="params">watcher: Watcher</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (watcher === <span class="title class_">Dep</span>.<span class="property">target</span> &amp;&amp; watcher.<span class="property">noRecurse</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has[id] = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">    queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">    <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">    <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// queue the flush</span></span><br><span class="line">  <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">    waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="title function_">flushSchedulerQueue</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-flushSchedulerQueue-函数做什么"><a href="#2-3-flushSchedulerQueue-函数做什么" class="headerlink" title="2.3 flushSchedulerQueue() 函数做什么"></a>2.3 flushSchedulerQueue() 函数做什么</h2><p><code>flushSchedulerQueue()</code> 函数遍历 queue ，通知对应的 watcher 去渲染更新</p><p>首先调用 watcher.run()  </p><p>run()内部则 watcher.get()</p><p>会调用 渲染更新方法</p><blockquote><p>这里涉及的 watcher 在后面的文章会提到</p></blockquote><div align="center">    <img src="/2023/07/08/Vue2源码：nextTick原理/流程.png" style="height: 270px; width: 700px;"></div><h2 id="2-4-nextTick-函数"><a href="#2-4-nextTick-函数" class="headerlink" title="2.4 nextTick() 函数"></a>2.4 nextTick() 函数</h2><blockquote><p>源码位置：vue-main\src\core\util\next-tick.ts</p></blockquote><p>进入该函数后，这时候第二个数组也用到了</p><p>它会将<strong>回调函数推入callbacks</strong>中，当前callbacks数组状态： [ flushSchedulerQueue() ]</p><p>然后调用 <code>timerFunc() </code> 函数，<strong>这个函数会依次执行 <code>callbacks</code> 中的回调函数</strong></p><p>但是 <code>timerFunc() </code> 函数能随随便便的执行吗？</p><p>不行</p><p>我们要 保证执行一个事件循环中只执行一次  <code>timerFunc() </code> ，就需要加上<strong>锁机制：pending变量</strong></p><p>变量 <code>pending</code> 设置布尔值，用来保证执行一个事件循环中只执行一次 <code>timerFunc()</code>函数。</p><p>如果 <code>timerFunc()</code> 函数执行后，才会改变 <code>pending</code> 值</p><p>看看源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb?: (...args: any[]) =&gt; any, ctx?: object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-timerFunc-函数"><a href="#2-5-timerFunc-函数" class="headerlink" title="2.5 timerFunc() 函数"></a>2.5 timerFunc() 函数</h2><p>考虑兼容性，<code>timerFunc()</code> 内部以优雅降级的方式执行回调函数</p><ul><li>内部先采用的是 promise（ie不兼容）  </li><li>不兼容则使用 MutationObserver(h5的api)  </li><li>否则可以考虑ie专享的 setImmediate  </li><li>或者 setTimeout</li></ul><p>执行时调用 <code>flushCallbacks(</code>) 函数，去遍历 callbacks 执行回调函数</p><p>看看源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (<span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-用户定义nextTick"><a href="#2-6-用户定义nextTick" class="headerlink" title="2.6 用户定义nextTick()"></a>2.6 用户定义nextTick()</h2><p>如果当前用户使用 <strong>vue 的 nextTick(</strong>)，传入自己的回调函数 <strong>myFn()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$nextTick( <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Element</span>.<span class="property">innerHTML</span>)</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p>内部执行**nextTick()**后</p><p>然后当前callbacks数组状态： [ flushSchedulerQueue(), myFn() ]</p><p>最后当执行 <code>timerFunc()</code> 函数时，遍历 callbacks ，执行对应的回调函数</p><p>实现：<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong></p><h1 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3 流程图"></a>3 流程图</h1><div align="center">    <img src="/2023/07/08/Vue2源码：nextTick原理/main.png" style="height: 500px; width: 600px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染性能优化：懒加载-异步解码</title>
      <link href="/2023/07/06/%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD-%E5%BC%82%E6%AD%A5%E8%A7%A3%E7%A0%81/"/>
      <url>/2023/07/06/%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD-%E5%BC%82%E6%AD%A5%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>懒加载是一种网页性能优化的常见方式，它能极大的提升用户体验。到今天，一个网站里面可能会有几百张甚至几千张上万张图片和其他资源，如果每次进入页面都需要请求页面上的所有的资源，会较大的影响用户体验，对用户的带宽也是一种极大的损耗。</p><p>所以，懒加载的意义即是，<strong>当页面未滚动到相应区域，该区域内的资源（网络请求）不会被加载。反之，当页面滚动到相应区域，相关资源的请求才会被发起。</strong></p><p>之前，图片的懒加载通常都是使用 JavaScript 方案进行：</p><blockquote><p>先给页面的图片设置一个占位符，不要把图片真实地址放在src中，真正的路径存储在一个属性中，要用的时候再取出来，页面加载完成后，判断图片是否在用户视野，如果在，就把值取出放入src属性；</p><p>如果 offsetTop - scrollTop &lt; clientHeight，说明图片出现在可视区域</p></blockquote><p>而今天，我们在懒加载实现上，有了更多不一样的选择。下面会介绍两种方式并进行测验:</p><ul><li>content-visibility: auto</li><li>loading&#x3D;”lazy” 和 decoding&#x3D;”async”</li></ul><h1 id="1-使用-content-visibility-实现延迟渲染"><a href="#1-使用-content-visibility-实现延迟渲染" class="headerlink" title="1 使用 content-visibility 实现延迟渲染"></a>1 使用 content-visibility 实现延迟渲染</h1><h2 id="1-1-What"><a href="#1-1-What" class="headerlink" title="1.1 What"></a>1.1 What</h2><p> <code>content-visibility： auto</code></p><p>其控制一个元素，直到需要它的时候才会渲染</p><p>利用 content-visibility ，我们可以实现如果该元素当前不在屏幕上，则不会渲染其后代元素。</p><h2 id="1-2-Demo"><a href="#1-2-Demo" class="headerlink" title="1.2 Demo"></a>1.2 Demo</h2><p>如果有如下页面结构，我使用 items 数组存放15个照片，都是通过网络请求拿到的，模板中进行渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span> :key=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>-------------&#123;&#123; item.id &#125;&#125;-------------<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">items</span>: [&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://b.hiphotos.baidu.com/image/pic/item/9d82d158ccbf6c81b94575cfb93eb13533fa40a2.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;https://gtd.alicdn.com/sns_logo/i3/TB1wnBTKFXXXXcQXXXXSutbFXXX.jpg_240x240xz.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;//www.baidu.com/img/flexible/logo/pc/result.png&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/a1ec08fa513d2697e542494057fbb2fb4316d81e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">4</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://c.hiphotos.baidu.com/image/pic/item/30adcbef76094b36de8a2fe5a1cc7cd98d109d99.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">5</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://h.hiphotos.baidu.com/image/pic/item/7c1ed21b0ef41bd5f2c2a9e953da81cb39db3d1d.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">6</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/55e736d12f2eb938d5277fd5d0628535e5dd6f4a.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">7</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4e4a20a4462309f7e41f5cfe760e0cf3d6cad6ee.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">8</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/6d81800a19d8bc3e770bd00d868ba61ea9d345f2.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">9</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4bed2e738bd4b31c1badd5a685d6277f9e2ff81e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">10</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/0d338744ebf81a4c87a3add4d52a6059252da61e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">11</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://a.hiphotos.baidu.com/image/pic/item/f2deb48f8c5494ee5080c8142ff5e0fe99257e19.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">12</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://f.hiphotos.baidu.com/image/pic/item/4034970a304e251f503521f5a586c9177e3e53f9.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">13</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://b.hiphotos.baidu.com/image/pic/item/279759ee3d6d55fbb3586c0168224f4a20a4dd7e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">14</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://a.hiphotos.baidu.com/image/pic/item/e824b899a9014c087eb617650e7b02087af4f464.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>页面看起来是这样的：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/contentVisibility.png" style="height: 500px; width: 500px;"></div><p>只需要给需要延迟（实时）渲染的元素，设置简单的 CSS 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-box</span> &#123;</span><br><span class="line">  <span class="attribute">content-visibility</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以实现延迟加载了</p><h2 id="1-3-可访问性"><a href="#1-3-可访问性" class="headerlink" title="1.3 可访问性"></a>1.3 可访问性</h2><p>全文检索是一个重要的功能</p><p>如果说可视区外的内容未被渲染，那是否会影响用户进行全文检索呢？</p><p>在页面初始化后，我全局 <code>ctrl + F</code>，搜索 7 ，全局查找的时候，可以找到当前未被渲染的元素内的内容</p><p>因此，<strong>即便存在设置了 <code>content-visibility: auto</code> 的未被渲染的元素，但是它并不会影响全局的搜索功能</strong>。</p><h2 id="1-4-But"><a href="#1-4-But" class="headerlink" title="1.4 But"></a>1.4 But</h2><p>文章还没到一半，当然不会就这么结束了</p><p>因为有2个<strong>缺点</strong>：</p><ul><li><strong>滚动条在向下滚动在不断的抖动：</strong>这是由于下面不在可视区域内的内容，一开始是没有被渲染的，在每次滚动的过程中，才逐渐渲染导致滚动条抽搐，用户体验挺差的</li></ul><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/contentVisibility.webp" style="height: 500px; width: 500px;"></div><ul><li><strong>初始化时请求全部发送了：</strong>即便当前页面可视区域外的内容未被渲染，但是图片资源的 HTTP&#x2F;HTTPS 请求，依然会在页面一开始被触发</li></ul><h3 id="1-3-1-利用-contain-intrinsic-size-解决滚动条抖动问题"><a href="#1-3-1-利用-contain-intrinsic-size-解决滚动条抖动问题" class="headerlink" title="1.3.1 利用 contain-intrinsic-size 解决滚动条抖动问题"></a>1.3.1 利用 contain-intrinsic-size 解决滚动条抖动问题</h3><p>当我们使用 <code>content-visibility: auto</code>，那么可视区外的元素高度通常就为 0，当滚动条移动，元素展示，所以会出现抖动抽搐。</p><p>如果能准确知道设置了<strong>元素在渲染状态下的高度</strong>，就可以避免抖动现象了。</p><p>因此我为元素加上 contain-intrinsic-size 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-box</span> &#123;</span><br><span class="line">  <span class="attribute">contain</span>-intrinsic-size: <span class="number">320px</span>;</span><br><span class="line">  <span class="attribute">content-visibility</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/解决抖动.webp" style="height: 500px; width: 500px;"></div><p><strong>所以，content-visibility: auto 无法完全替代图片懒加载，设置了 content-visibility: auto 的确实现了延迟渲染，但是其中的静态资源仍旧会在页面初始化的时候被全部加载。因此，它更适合于虚拟列表渲染的情景。</strong></p><h1 id="2-懒加载-异步解码"><a href="#2-懒加载-异步解码" class="headerlink" title="2 懒加载+异步解码"></a>2 懒加载+异步解码</h1><h2 id="2-1-懒加载-loading-x3D-”lazy”"><a href="#2-1-懒加载-loading-x3D-”lazy”" class="headerlink" title="2.1 懒加载 loading&#x3D;”lazy”"></a>2.1 懒加载 loading&#x3D;”lazy”</h2><p>HTML5 新增了一个 loading 属性。此属性可以添加到 &lt; img &gt; 元素中，也可以添加到 &lt; iframe &gt; 元素中。</p><p>属性的值为 loading&#x3D;”lazy” 会告诉浏览器，如果图像位于可视区时，则立即加载图像，并在用户滚动到它们附近时获取其他图像。</p><p>loading&#x3D;”lazy” 到（2023-07-08）的兼容性，还是非常不错的：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/loading兼容.png" style="height: 300px; width: 900px;"></div><h2 id="2-2-异步解码-decoding-x3D-”async”"><a href="#2-2-异步解码-decoding-x3D-”async”" class="headerlink" title="2.2 异步解码 decoding&#x3D;”async”"></a>2.2 异步解码 decoding&#x3D;”async”</h2><p><code>HTMLImageElement</code> 接口的 <code>decoding</code> 属性用于告诉浏览器使用何种方式解析图像数据。</p><ul><li>sync: 同步解码图像，保证与其他内容一起显示。</li><li>async: 异步解码图像，加快显示其他内容。</li><li>auto: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。</li></ul><p>浏览器在进行图片渲染展示的过程中，是需要对图片文件进行解码的，这一个过程快慢与图片格式有关。</p><p>而如果我们不希望图片的渲染解码影响页面的其他内容的展示，可以使用 async 选项</p><p>这样，浏览器便会异步解码图像，加快显示其他内容，优化页面渲染性能。</p><p>同样的，我们来看看到（2023-07-08），decoding&#x3D;”async” 的兼容性，整体还是非常不错的，作为渐进增强方案使用，是非常好的选择。</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/decoding兼容.png" style="height: 300px; width: 900px;"></div><h2 id="2-3-Demo"><a href="#2-3-Demo" class="headerlink" title="2.3 Demo"></a>2.3 Demo</h2><p>和上面的Demo差不多，准备14张图片的页面，每个图片url大小不一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;!-- loading=&quot;lazy&quot; 懒加载 --&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container-box2&quot;&gt;</span><br><span class="line">        &lt;p&gt;-------------&#123;&#123; item.id &#125;&#125;-------------&lt;/p&gt;   </span><br><span class="line">        &lt;img :src=&quot;item.src&quot; alt=&quot;&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#123;</span><br><span class="line">        id: 0,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/6d81800a19d8bc3e770bd00d868ba61ea9d345f2.jpg&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        src: &quot;https://gtd.alicdn.com/sns_logo/i3/TB1wnBTKFXXXXcQXXXXSutbFXXX.jpg_240x240xz.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        src: &quot;//www.baidu.com/img/flexible/logo/pc/result.png&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 3,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/a1ec08fa513d2697e542494057fbb2fb4316d81e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        src: &quot;http://c.hiphotos.baidu.com/image/pic/item/30adcbef76094b36de8a2fe5a1cc7cd98d109d99.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 5,</span><br><span class="line">        src: &quot;http://h.hiphotos.baidu.com/image/pic/item/7c1ed21b0ef41bd5f2c2a9e953da81cb39db3d1d.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 6,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/55e736d12f2eb938d5277fd5d0628535e5dd6f4a.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 7,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/4e4a20a4462309f7e41f5cfe760e0cf3d6cad6ee.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 8,</span><br><span class="line">        src: &quot;http://b.hiphotos.baidu.com/image/pic/item/9d82d158ccbf6c81b94575cfb93eb13533fa40a2.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 9,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/4bed2e738bd4b31c1badd5a685d6277f9e2ff81e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 10,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/0d338744ebf81a4c87a3add4d52a6059252da61e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 11,</span><br><span class="line">        src: &quot;http://a.hiphotos.baidu.com/image/pic/item/f2deb48f8c5494ee5080c8142ff5e0fe99257e19.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 12,</span><br><span class="line">        src: &quot;http://f.hiphotos.baidu.com/image/pic/item/4034970a304e251f503521f5a586c9177e3e53f9.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 13,</span><br><span class="line">        src: &quot;http://b.hiphotos.baidu.com/image/pic/item/279759ee3d6d55fbb3586c0168224f4a20a4dd7e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 14,</span><br><span class="line">        src: &quot;http://a.hiphotos.baidu.com/image/pic/item/e824b899a9014c087eb617650e7b02087af4f464.jpg&quot;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由于是纯图片页面，需要给给图片设置默认宽高。</p><p>否则初次刷新时，元素的宽高都是 0，会导致所有元素都在可视区内。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">202px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">166px</span>;</span><br><span class="line">    <span class="attribute">object-fit</span>: cover; <span class="comment">/* 居中自动剪裁图片 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/懒加载.webp" style="height: 500px; width: 500px;"></div><p>可以看到，初次加载时，只会请求当前页面的资源，随着可视区域变化，再进行资源请求</p><h2 id="2-4-性能测试"><a href="#2-4-性能测试" class="headerlink" title="2.4 性能测试"></a>2.4 性能测试</h2><p>为了验证性能，在上面的Demo基础上，进行对比测试。</p><p>首先是没有添加懒加载的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，初次页面加载时会请求所有资源，<strong>页面 Load 事件完成的时间竟然有 14.96 s</strong></p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/对比实验1.png" style="height: 130px; width: 800px;"></div><p>现在我们为他加上 loading&#x3D;”lazy” 与 decoding&#x3D;async”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">decoding</span>=<span class="string">&quot;async&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>首次进入页面仅请求显示在屏幕上的图片，<strong>页面 Load 事件完成的时间为 597 ms</strong></p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/对比实验2.png" style="height: 130px; width: 800px;"></div><p>当页面滚动时，显示的图片才会继续发送请求</p><h1 id="3-总结一下"><a href="#3-总结一下" class="headerlink" title="3 总结一下"></a>3 总结一下</h1><ul><li>content-visibility: auto + contain-intrinsic-size 可以实现延迟渲染，并且不会影响全局的搜索功能<ul><li>但是初始化时，资源会全部加载，因此不太适合做图片懒加载，更适合于虚拟列表场景</li></ul></li><li>loading&#x3D;”lazy” + decoding&#x3D;”async” 可以实现懒加载+异步解码，浏览器只会加载可视区的资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
