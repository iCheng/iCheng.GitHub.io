<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue 转 React 指南</title>
      <link href="/2023/08/10/Vue%E8%BD%ACReact%E6%8C%87%E5%8D%97/"/>
      <url>/2023/08/10/Vue%E8%BD%ACReact%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h1><p>先介绍 React 唯一的一个语法糖：JSX。</p><p>理解 JSX 语法并不困难，简单记住一句话，遇到 <code>&#123;&#125;</code> 符号内部解析为 JS 代码，遇到成对的 <code>&lt;&gt;</code> 符号内部解析为 HTML 代码。</p><p>当你写下这个 React 组件时：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.hello&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会被自动工具翻译成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, <span class="literal">null</span>, props.<span class="property">hello</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 就是通过这个小小语法糖，实现在 JS 里面写 HTML，可能有小伙伴会说 HTML 与 JS 分离不是更好吗？责职分明，混合只会更乱。但当你体验到代码自动提示，自动检查，以及调试时精确定位到一行代码的好处时，就清楚 React 和 Vue 的差距了。</p><h1 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h1><p><strong>vue种采用双括号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p><strong>react采用单括号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function MyComponent(props) &#123;</span><br><span class="line">    let msg = &#x27;XXX&#x27;</span><br><span class="line">    return &lt;div&gt;&#123; msg &#125;&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h1><p><strong>vue中 想要响应式地绑定一个 attribute，应该使用 <code>v-bind</code> 指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>react中，使用单引号，或者使用单括号包裹表示动态绑定</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  let tmpID = &#x27;12&#x27;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div id=&#x27;12&#x27;&gt;id&lt;/div&gt;</span><br><span class="line">      &lt;div id=&#123;tmpID&#125;&gt;id&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态绑定多值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  let tmpObject = &#123;</span><br><span class="line">    id: 13,</span><br><span class="line">    className: &#x27;wrapper&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div &#123;...tmpObject&#125;&gt;id&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;13&quot; class=&quot;wrapper&quot;&gt;id&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="参数-Arguments"><a href="#参数-Arguments" class="headerlink" title="参数 Arguments"></a>参数 Arguments</h1><p><strong>某些指令会需要一个“参数”，Vue在指令名后通过一个冒号隔开做标识。例如用 <code>v-bind</code> 指令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><p><strong>React中则没有指令一说，而是采用如下方式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// href跳转</span><br><span class="line">function App () &#123;</span><br><span class="line">  let tmpURL = &#x27;https://www.XXXXXXXX&#x27;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;a href=&#123;tmpURL&#125;&gt;&lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-JS-表达式"><a href="#使用-JS-表达式" class="headerlink" title="使用 JS 表达式"></a>使用 JS 表达式</h1><p><strong>React 遇到 <code>&#123;&#125;</code> 符号内部解析为 JS 代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  let tmpString = &#x27;--&#x27;;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div &gt;&#123;1 + 1&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div &gt;&#123;&#x27;a&#x27; + &#x27;b&#x27;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;div &gt;&#123;`1$&#123;tmpString&#125;1`&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;2&lt;/div&gt;</span><br><span class="line">&lt;div&gt;ab&lt;/div&gt;</span><br><span class="line">&lt;div&gt;1--1&lt;/div&gt;</span><br></pre></td></tr></table></figure><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><p><strong>Vue中绑定事件处理：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- `greet` 是上面定义过的方法名 --&gt;</span><br><span class="line">&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>React可以通过在组件中声明 事件处理 函数来响应事件</strong></p><p>React中点击事件使用小驼峰形式：onClick</p><p>在标签上写函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div onClick=&#123;() =&gt; alert(&#x27;点击出现弹框&#x27;)&#125;&gt;按钮&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提前声明函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  function myFun () &#123;</span><br><span class="line">    alert(&#x27;点击出现弹框&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div onClick=&#123;myFun&#125;&gt;按钮&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>onClick=&#123;handleClick&#125;</code> 的结尾没有小括号！不要 <strong>调用</strong> 事件处理函数：你只需 <strong>传递给事件</strong> 即可。当用户点击按钮时，React 会调用你的事件处理函数。</p><p>函数传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  function myFun (str) &#123;</span><br><span class="line">    alert(str)</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div onClick=&#123;() =&gt; myFun(&#x27;点击出现弹框&#x27;)&#125;&gt;按钮&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h1><p><strong>Vue在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 简写 --&gt;</span><br><span class="line">&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;</span><br></pre></td></tr></table></figure><p>举例来说，如果你的组件实例有一个数据属性 <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定就等价于 <code>v-bind:href</code>。</p><p><strong>React 也可以通过动态参数绑定</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  const obj = &#123;</span><br><span class="line">    onClick: () =&gt; alert(&#x27;点击出现弹框&#x27;),</span><br><span class="line">    // ...还可以写更多事件</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;div &#123;...obj&#125;&gt;按钮&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="修饰符-Modifiers"><a href="#修饰符-Modifiers" class="headerlink" title="修饰符 Modifiers"></a>修饰符 Modifiers</h1><p>vue 修饰符是以点开头的特殊后缀</p><p>表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;...&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>React 则是依靠于JS基础</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  function onSubmit(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &lt;form onSubmit=&#123;onSubmit&#125;&gt;</span><br><span class="line">        &lt;button type=&#x27;submit&#x27;&gt;&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><p><strong>为了实现视图更新，VUE中响应式是一个重要的概念</strong></p><p><strong>而 React 中并没有响应式这个概念，要实现视图更新，需要在 React 引入 <code>useState</code></strong></p><p>通常，你会希望你的组件 “记住” 一些信息并展示出来。例如，也许你想计算一个按钮被点击的次数。要做到这一点，你需要在你的组件中添加 <strong>state</strong>。</p><p>首先，从 React 引入 <code>useState</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br></pre></td></tr></table></figure><p>现在你可以在你的组件中声明一个 <strong>state 变量</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  // ...</span><br></pre></td></tr></table></figure><p>你将从 <code>useState</code> 中获得两样东西：当前的 state（<code>count</code>），以及用于更新它的函数（<code>setCount</code>）。你可以给它们起任何名字，但按照惯例，需要像这样 <code>[something, setSomething]</code> 为它们命名。</p><p>第一次显示按钮时，<code>count</code> 的值为 <code>0</code>，因为你把 <code>0</code> 传给了 <code>useState()</code>。当你想改变 state 时，调用 <code>setCount()</code> 并将新的值传递给它。点击该按钮计数器将递增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function MyButton() &#123;</span><br><span class="line">  const [count, setCount] = useState(0);</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    setCount(count + 1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;button onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Clicked &#123;count&#125; times</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 将再次调用你的组件函数。这次，<code>count</code> 会变成 <code>1</code>。接着，变成 <code>2</code>。以此类推。</p><p>如果你多次渲染同一个组件，每个组件都会拥有自己的 state。你可以尝试点击不同的按钮：</p><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>Vue中使用 watch 来实现计算属性（缓存计算的结果）</p><p><strong>React 在组件的顶层调用 <code>useMemo</code> 来缓存每次重新渲染都需要计算的结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; useMemo &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">function App () &#123;</span><br><span class="line">  const [user] = useState(&#123; firstname: &#x27;a&#x27;, lastname: &#x27;b&#x27; &#125;)</span><br><span class="line"></span><br><span class="line">  const fullname = useMemo(() =&gt; &#123;</span><br><span class="line">    return user.firstname + user.lastname;</span><br><span class="line">  &#125;, [user.firstname, user.lastname])</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#x27;App&#x27;&gt;</span><br><span class="line">      &#123;fullname&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>useMemo(calculateValue, dependencies)</strong></p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul><li><code>calculateValue</code>：要缓存计算值的函数。它应该是一个没有任何参数的纯函数，并且可以返回任意类型。React 将会在首次渲染时调用该函数；在之后的渲染中，如果 <code>dependencies</code> 没有发生变化，React 将直接返回相同值。否则，将会再次调用 <code>calculateValue</code> 并返回最新结果，然后缓存该结果以便下次重复使用。</li><li><code>dependencies</code>：所有在 <code>calculateValue</code> 函数中使用的响应式变量组成的数组。响应式变量包括 props、state 和所有你直接在组件中定义的变量和函数。如果你在代码检查工具中 <a href="https://react.docschina.org/learn/editor-setup#linting">配置了 React</a>，它将会确保每一个响应式数据都被正确地定义为依赖项。依赖项数组的长度必须是固定的并且必须写成 <code>[dep1, dep2, dep3]</code> 这种形式。React 使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> 将每个依赖项与其之前的值进行比较。</li></ul><h1 id="绑定-HTML-class"><a href="#绑定-HTML-class" class="headerlink" title="绑定 HTML class"></a>绑定 HTML class</h1><p>数据绑定的一个常见需求场景是操纵元素的 CSS class 列表和内联样式。因为 <code>class</code> 和 <code>style</code> 都是 attribute</p><p>Vue中可以给 <code>:class</code> (<code>v-bind:class</code> 的缩写) 传递一个对象来动态切换 class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div :class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>上面的语法表示 <code>active</code> 是否存在取决于数据属性 <code>isActive</code> 的真假值。</p><p>React实现方式基于js语法，其实有多种实现方式，列举三元运算符方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  let showColor = false</span><br><span class="line">  return (</span><br><span class="line">    // 现有box-show、box-hide两个class样式</span><br><span class="line">    &lt;div className=&#123;showColor ? &#x27;box-show&#x27; : &#x27;box-hide&#x27;&#125;&gt;&lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="语法糖转换"><a href="#语法糖转换" class="headerlink" title="语法糖转换"></a>语法糖转换</h1><p>习惯 Vue 的同学都知道很多语法糖，比如 <code>v-if</code>、<code>v-for</code>、<code>v-bind</code>、<code>v-on</code> 等，相比 Vue，React 只有一个语法糖，那就是 jsx&#x2F;tsx。<code>v-if</code> 这些功能在 React 上都是通过原生 javascript 实现的，慢慢你会发现，其实你学的不是 React，而是 Javascipt，React 赋予你通过 js 完整控制组件的能力，这部分明显比 Vue 的语法糖更加灵活，糖太多容易引来虫子（Bug）</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>vue 中写法是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1 v-if=&quot;ishow&quot;&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">    &lt;h1 v-else&gt;else&lt;/h1&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在 React 函数组件中，只需使用 js 三目运算符语法即可完成条件渲染的功能。或者使用 &amp;&amp; 逻辑，记住下面一句话就能过理解了：</p><blockquote><p>遇到 <code>&#123;&#125;</code> 符号内部解析为 JS 代码，遇到成对的 <code>&lt;&gt;</code> 符号内部解析为 HTML 代码</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  const ishow = false</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;ishow ? &lt;div&gt;awesome&lt;/div&gt; : &lt;div&gt;else&lt;/div&gt;&#125;</span><br><span class="line">      &#123;ishow &amp;&amp; &lt;h1&gt;React!&lt;/h1&gt;&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><p>Vue中通过v-for进行列表渲染</p><p><strong>React 通过 js 的数组语法 map，将数据对象映射为 DOM 对象</strong>。只需学会 js，无需记住各种指令，如果要做列表过滤，直接使用 <code>items.filter(...).map(...)</code> 链式调用即可，语法上更加灵活，如果为了提高渲染性能，使用 useMemo 进行优化即可，类似 Vue 的 computed。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  const arr = [&#123; message: &#x27;react&#x27; &#125;, &#123; message: &#x27;JS&#x27; &#125;]</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;arr.map((items, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;items.message&#125;&lt;/li&gt;)&#125;</span><br><span class="line">    &lt;/div &gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h1><p>Vue中使用 watch监听数据变化，触发回调</p><p>React中可以使用 useEffect 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App () &#123;</span><br><span class="line">  const [user, setUser] = useState(&#123;</span><br><span class="line">    firstname: &#x27;a&#x27;,</span><br><span class="line">    lastname: &#x27;b&#x27;</span><br><span class="line">  &#125;)</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&quot;1111&quot;)</span><br><span class="line">  &#125;, [user.firstname])</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setUser(&#123; ...user, firstname: &#x27;a2&#x27; &#125;)&#125;&gt;&lt;/button&gt;</span><br><span class="line">    &lt;/div &gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>N个实现水平垂直居中的方法</title>
      <link href="/2023/08/03/N%E4%B8%AA%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/08/03/N%E4%B8%AA%E5%AE%9E%E7%8E%B0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-行内元素的水平垂直居中"><a href="#1-行内元素的水平垂直居中" class="headerlink" title="1 行内元素的水平垂直居中"></a>1 行内元素的水平垂直居中</h1><h2 id="1-1-单行文本"><a href="#1-1-单行文本" class="headerlink" title="1.1 单行文本"></a>1.1 单行文本</h2><p>要实现行内元素的水平居中，只需把行内元素包裹在块级父层元素中，并且在父层元素CSS设置如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>center<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;   <span class="comment">/* 文本水平居中 */</span></span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;  <span class="comment">/* 文本垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/1.1.jpg" style="height: 150px; width: 300px;"></div><p>简单但是有缺点：<strong>只适应单行文本</strong></p><p>如果有多行文本，无法水平垂直居中</p><h2 id="1-2-多行文本"><a href="#1-2-多行文本" class="headerlink" title="1.2 多行文本"></a>1.2 多行文本</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>多行文本，使用flex布局，设置主轴和交叉轴的对齐方式就可以了</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>center555 okkk breakall alllbrake someyook oolmols looltheboy intergefer asda <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;  <span class="comment">/* 设置文本换行 （允许单词内换行） */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>:center;   <span class="comment">/* 水平居中: 设置交叉轴(垂直方向)方向上的对齐方式 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;  <span class="comment">/* 垂直居中：设置在主轴(横轴)上的对齐方式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/1.2.jpg" style="height: 150px; width: 300px;"></div><h3 id="grid布局"><a href="#grid布局" class="headerlink" title="grid布局"></a>grid布局</h3><p>也可以使用grid布局，设置单元格内容的 水平垂直位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>center555 okkk breakall alllbrake someyook oolmols looltheboy intergefer asda <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">word-break</span>: break-all;  <span class="comment">/* 设置文本换行 （允许单词内换行） */</span></span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  justify-self: center;   <span class="comment">/* 设置单元格内容的 水平位置 */</span></span><br><span class="line">  <span class="attribute">align-self</span>:center <span class="comment">/* 设置单元格内容的 垂直位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-块级元素"><a href="#2-块级元素" class="headerlink" title="2 块级元素"></a>2 块级元素</h1><h2 id="2-1-块状元素水平居中"><a href="#2-1-块状元素水平居中" class="headerlink" title="2.1 块状元素水平居中"></a>2.1 块状元素水平居中</h2><p>要实现块状元素（display:block）的水平居中，我们只需要将它的左右外边距 margin-left 和 margin-right 设置为 auto，即可实现块状元素的居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> auto;  <span class="comment">/* 块级元素水平居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/2.1.jpg" style="height: 150px; width: 700px;"></div><h2 id="2-2-块状元素水平垂直居中"><a href="#2-2-块状元素水平垂直居中" class="headerlink" title="2.2 块状元素水平垂直居中"></a>2.2 块状元素水平垂直居中</h2><h3 id="利用绝对定位与transform"><a href="#利用绝对定位与transform" class="headerlink" title="利用绝对定位与transform"></a>利用绝对定位与transform</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: aqua; width: 200px; height: 200px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css前3行代码，使得元素的左上角点位于水平垂直居中</p><p>translate() 这个 CSS 函数在水平和&#x2F;或垂直方向上重新定位元素，移动元素的宽高的一半</p><p>使得整个元素水平垂直居中</p><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/2.2.jpg" style="height: 150px; width: 400px;"></div><h3 id="利用绝对定位与margin"><a href="#利用绝对定位与margin" class="headerlink" title="利用绝对定位与margin"></a>利用绝对定位与margin</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: aqua; width: 200px; height: 200px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-多个块状元素的水平垂直居中"><a href="#2-3-多个块状元素的水平垂直居中" class="headerlink" title="2.3 多个块状元素的水平垂直居中"></a>2.3 多个块状元素的水平垂直居中</h2><h3 id="flex布局："><a href="#flex布局：" class="headerlink" title="flex布局："></a>flex布局：</h3><p>使用flex布局，定义项目在<strong>主轴&#x2F;交叉轴上的对齐方式</strong></p><p>使用flex布局，无需绝对定位等改变布局的操作，可以<strong>轻松</strong>实现元素的水平垂直居中</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: aqua; width: 1400px; height: 200px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: wheat; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;background-color: white; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: violet; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/2.3.jpg" style="height: 150px; width: 600px;"></div><h3 id="grid布局："><a href="#grid布局：" class="headerlink" title="grid布局："></a>grid布局：</h3><p>容器设置为grid布局后，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: aqua; width: 1400px; height: 500px;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: wheat; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color: white; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>  <span class="attr">style</span>=<span class="string">&quot;background-color: violet; height: 100px; width: 100px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="comment">/* 划分列 3列 各200px */</span></span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> <span class="number">200px</span> <span class="number">200px</span>; </span><br><span class="line">  <span class="comment">/* 容器位置 水平垂直居中 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="comment">/* 单元格的内容 居中 */</span></span><br><span class="line">  justify-self: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/08/03/N个实现水平垂直居中的方法/2.3.2.jpg" style="height: 280px; width: 600px;"></div>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>性能优化之事件委托</title>
      <link href="/2023/08/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
      <url>/2023/08/02/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-大量函数会影响性能"><a href="#1-大量函数会影响性能" class="headerlink" title="1 大量函数会影响性能"></a>1 大量函数会影响性能</h1><p>页面的事件处理程序的数量与页面的整体性能是相挂钩的。</p><ul><li>一方面：事件处理函数本质上是对象，存放在内存中，设置大量的事件处理函数会使内存中的对象变多，影响程序的性能和用户体验</li><li>另一方面：为指定事件处理程序所需访问DOM的次数会先期造成整个页面交互的延迟</li></ul><p>“过多事件处理程序” 的解决方案就是使用事件委托</p><h1 id="2-什么是事件委托"><a href="#2-什么是事件委托" class="headerlink" title="2 什么是事件委托"></a>2 什么是事件委托</h1><p>事件流的都会经过三个阶段： 捕获阶段 -&gt; 目标阶段 -&gt; 冒泡阶段，而<strong>事件委托就是在冒泡阶段</strong>完成</p><p>事件委托，会把一个或者一组元素的事件，委托到它的父层或者更外层元素上，当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数，这样真正绑定事件的是外层元素，而不是目标元素</p><h2 id="2-1举例：冒泡和捕获的具体区别"><a href="#2-1举例：冒泡和捕获的具体区别" class="headerlink" title="2.1举例：冒泡和捕获的具体区别"></a>2.1举例：冒泡和捕获的具体区别</h2><p>下面为div1 div2绑定点击捕获和冒泡事件，看看事件的执行流程</p><p><strong>HTML</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JS</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div1&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> div2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;div2&quot;</span>);</span><br><span class="line">    div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;div1--捕获阶段&quot;</span>)</span><br><span class="line">    &#125;,<span class="literal">true</span>);</span><br><span class="line">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;div2--捕获阶段&quot;</span>)</span><br><span class="line">    &#125;,<span class="literal">true</span>);</span><br><span class="line">    div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;div1--冒泡阶段&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    div2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;div2--冒泡阶段&quot;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>输出结果（点击div2的时候执行的结果）</strong></p><div align="center">    <img src="/2023/08/02/性能优化之事件委托/捕获冒泡.png" style="height: 300px; width: 500px;"></div><h1 id="3-如何实现"><a href="#3-如何实现" class="headerlink" title="3 如何实现"></a>3 如何实现</h1><p>当前页面下，如果要实现为每个 <strong>&lt; li &gt;</strong> 绑定一个点击事件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span>Go somewhere<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通常的做法是像这样绑定三个点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> item1 = <span class="variable language_">document</span> .<span class="title function_">getElementById</span>( <span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item2 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>( <span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> item3 =<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">item1.<span class="property">addEventListener</span> (<span class="string">&quot;click&quot;</span>,<span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item1&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">item2.<span class="title function_">addEventListener</span>( <span class="string">&quot;click&quot;</span>, （event） =&gt;&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item2&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">item3 .<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, （event) =&gt;&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item3&#x27;</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>这样的结果就是所使用的 onclick 事件处理程序都如法炮制，出现大量雷同的指定事件处理程序的代码</strong></p><p>如下代码，使用事件委托，只要给所有元素的祖先节点添加一个处理程序就可以了（addEventListener 第三个参数默认false，冒泡阶段触发）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">addEventListener</span>(<span class="string">&#x27;cliCK&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target = event.<span class="property">target</span>;</span><br><span class="line">    <span class="keyword">switch</span>(target.<span class="property">id</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span> :</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item1&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item1&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item1&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">)&#125;;</span><br></pre></td></tr></table></figure><p>这里只给ul元素添加了一个onclick事件处理程序。</p><p>因为所有列表项都是这个元素的后代，所以它们的事件会向上冒泡，最终都会由这个函数来处理。</p><p>但事件目标是每个被点击的列表项，只要检查event对象的id属性就可以确定，然后再执行相应的操作即可。</p><p>相对于前面不使用事件委托的代码，这里的代码只访问了一个 DOM元素和添加了一个事件处理程序，占用内存更少。</p><h1 id="4-Vue中实践"><a href="#4-Vue中实践" class="headerlink" title="4 Vue中实践"></a>4 Vue中实践</h1><p>如下 DOM 结构</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick&quot;</span>&gt;</span>点击事件1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick2&quot;</span>&gt;</span>点击事件2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick3&quot;</span>&gt;</span>点击事件3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick4&quot;</span>&gt;</span>点击事件4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick5&quot;</span>&gt;</span>点击事件5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick6&quot;</span>&gt;</span>点击事件6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick7&quot;</span>&gt;</span>点击事件7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick8&quot;</span>&gt;</span>点击事件8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick9&quot;</span>&gt;</span>点击事件9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handClick10&quot;</span>&gt;</span>点击事件10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>把事件统一绑定到父节点上,在父节点上统一处理从子节点冒泡上来的事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul @click=<span class="string">&quot;handClick&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span>&gt;</span>点击事件1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span>&gt;</span>点击事件2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件8<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件9<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span>&gt;</span>点击事件10<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(6)：侦听器原理</title>
      <link href="/2023/07/23/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%A6%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/23/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%A6%E5%90%AC%E5%99%A8%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>watch的源码原理属于比较简单清晰的了</p><p>当然要理解还需要配合前面几篇：依赖收集、派发更新、数据劫持</p><h1 id="1-watch的入口"><a href="#1-watch的入口" class="headerlink" title="1 watch的入口"></a>1 watch的入口</h1><blockquote><p>源码位置：vue-main\src\core\instance\state.ts</p></blockquote><p>initState() 方法中，判断 opts.watch 如果存在，则执行 initWatch 进行监听器初始化</p><h1 id="2-创建-user-Watcher"><a href="#2-创建-user-Watcher" class="headerlink" title="2 创建 user Watcher"></a>2 创建 user Watcher</h1><p>首先 Vue 中定义了 3 个 watcher</p><ul><li>render watcher：模板依赖并且需要显示在视图上变量，其内部保存了一个 render watcher</li><li>computed watcher：计算属性内部保存了一个 computed watcher</li><li>user watcher：使用 watch 侦听的属性内部保存了一个 user watcher</li></ul><p>user watcher 就是侦听器创建的，下面我们来看看是怎样实现的</p><h2 id="2-1-watch的写法"><a href="#2-1-watch的写法" class="headerlink" title="2.1 watch的写法"></a>2.1 watch的写法</h2><p>首先，我们要了解 watch 的几种写法</p><p>数组写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">firstname</span>: [</span><br><span class="line">      <span class="function">(<span class="params">newValue,oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">newValue,oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>字符串写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="title function_">firstname</span>(<span class="params">newValue,oldValue</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="2-2-initWatch-初始化"><a href="#2-2-initWatch-初始化" class="headerlink" title="2.2 initWatch 初始化"></a>2.2 initWatch 初始化</h2><p>这里用来<strong>判断 watch侦听器 的类型</strong></p><ul><li>如果是数组形式，则遍历，依次创建 Wacther</li><li>否则，直接创建 Wacther</li></ul><p>看看源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initWatch</span>(<span class="params">vm: Component, watch: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isArray</span>(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; handler.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="title function_">createWatcher</span>(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">createWatcher</span>(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-创建-Watcher"><a href="#2-3-创建-Watcher" class="headerlink" title="2.3 创建 Watcher"></a>2.3 创建 Watcher</h2><ul><li>第一步，首先 <strong>拿到侦听器的回调函数 handler</strong></li><li>第二步，将 回调函数 handler 作为参数，<strong>去创建 Watcher</strong></li></ul><p>第一步：</p><p>createWatcher() 方法中源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createWatcher</span>(<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  expOrFn: string | (() =&gt; any),</span></span><br><span class="line"><span class="params">  handler: any,</span></span><br><span class="line"><span class="params">  options?: <span class="built_in">Object</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isPlainObject</span>(handler)) &#123;</span><br><span class="line">    options = handler</span><br><span class="line">    handler = handler.<span class="property">handler</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回调是字符串的情况</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    handler = vm[handler]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去创建 Watcher</span></span><br><span class="line">  <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：回调是字符串的情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line"><span class="title function_">myFn</span>(<span class="params">newValue, oldValue</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;changed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line"><span class="attr">firstname</span>: <span class="string">&#x27;myFn&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步：</p><p>然后会执行 <strong>vm上的$watch</strong>， <strong>去创建 Watcher</strong></p><blockquote><p>源码位置：vue-main\src\core\instance\state.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user置为true 表示创建监听器的watcher</span></span><br><span class="line">options.<span class="property">user</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 创建创建监听器的watcher</span></span><br><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, expOrFn, cb, options) <span class="comment">// expOrFn是函数名 cb是回调函数</span></span><br></pre></td></tr></table></figure><p>到这里，user Watcher 就创建好了</p><h1 id="3-初始化和更新"><a href="#3-初始化和更新" class="headerlink" title="3 初始化和更新"></a>3 初始化和更新</h1><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><p>当我们在代码中使用了 watch侦听器</p><p>经过初始化后，创建好了 user Watcher</p><p>经过上面的流程后，最终会进入 <code>new Watcher</code> 的逻辑，这里面也是依赖收集和更新的触发点</p><p>Watcher 会默认调用 <strong>get()</strong> 方法，<strong>这是 watcher 求值的普遍方法</strong></p><ul><li>首先 pushTarget  将当前的 user Watcher 挂到 <code>Dep.target</code> 上。</li><li>然后调用 <code>getter</code> 函数，<strong>做依赖收集，拿到新值</strong></li><li>最后 popTarget() 弹出</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)  <span class="comment">// 调用函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-更新"><a href="#3-2-更新" class="headerlink" title="3.2 更新"></a>3.2 更新</h2><p>当修改侦听的属性后</p><p>数据劫持会触发 set</p><p>因为前面做过依赖收集了，在派发更新时，会通知 user Watcher 执行 update（最终会执行run方法）</p><p>run() 方法中：</p><ul><li>会触发 get() 取新值 <strong>value</strong></li><li>并缓存旧值 <strong>oldValue</strong></li><li>最后触发回调函数 <strong>cb</strong></li></ul><p>run() 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">    <span class="comment">// 拿到新值</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mutated.</span></span><br><span class="line">      <span class="title function_">isObject</span>(value) ||</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// 缓存旧值</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">      <span class="comment">// 赋予新值</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="comment">// 触发回调函数 cb</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">        <span class="title function_">invokeWithErrorHandling</span>(</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">cb</span>,</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">          [value, oldValue],</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">vm</span>,</span><br><span class="line">          info</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-深度监听"><a href="#4-深度监听" class="headerlink" title="4 深度监听"></a>4 深度监听</h1><p>深度监听是 <code>watch</code> 监听中一项很重要的配置，它能为我们观察对象中任何一个属性的变化。</p><p>目光再拉回到 <strong>get()</strong> 函数，其中有一段代码是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">  <span class="title function_">traverse</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>traverse方法源码位置：&#x2F;src&#x2F;core&#x2F;observer&#x2F;traverse.js</p></blockquote><p>它主要做的事情就是：</p><p>递归获取每一项属性，触发它们的“数据劫持<code>get</code>”收集依赖</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(5)：计算属性原理</title>
      <link href="/2023/07/23/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/23/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算属性"><a href="#1-计算属性" class="headerlink" title="1 计算属性"></a>1 计算属性</h1><p>首先 Vue 中定义了 3 个 watcher</p><ul><li>render watcher：模板依赖并且需要显示在视图上变量，其内部保存了一个 render watcher</li><li>computed watcher：计算属性内部保存了一个 computed watcher</li><li>user watcher：使用 watch 侦听的属性内部保存了一个 user watcher</li></ul><p>render watcher 之前的文章已经分析过了</p><p>下面会分析一下 computed watcher 的实现原理</p><h1 id="2-计算属性的初始化过程"><a href="#2-计算属性的初始化过程" class="headerlink" title="2 计算属性的初始化过程"></a>2 计算属性的初始化过程</h1><p>一个计算属性的初始化分为2部分</p><ul><li>实例化一个 computed watcher</li><li>定义计算属性的 getter 函数</li></ul><h2 id="2-1-创建-computed-watcher"><a href="#2-1-创建-computed-watcher" class="headerlink" title="2.1 创建 computed watcher"></a>2.1 创建 computed watcher</h2><h3 id="2-1-1-计算属性的两种写法"><a href="#2-1-1-计算属性的两种写法" class="headerlink" title="2.1.1 计算属性的两种写法"></a>2.1.1 计算属性的两种写法</h3><p>首先计算属性有两种写法：直接写为 function 和 完整写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">// defineProperty中的get方法</span></span><br><span class="line">    fullname () &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstname</span> + <span class="variable language_">this</span>.<span class="property">lastname</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 完整写法</span></span><br><span class="line">    <span class="attr">fullname</span>:&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;run&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstname</span> + <span class="variable language_">this</span>.<span class="property">lastname</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newVal)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如何求得 fullname 值，第一种方法可以拿来直接用，第二种需要拿到它的get</p><h3 id="2-1-2-实例化一个-computed-watcher"><a href="#2-1-2-实例化一个-computed-watcher" class="headerlink" title="2.1.2 实例化一个 computed watcher"></a>2.1.2 实例化一个 computed watcher</h3><blockquote><p>源码路径：vue-main\src\core\instance\state.ts</p></blockquote><p>在初始化当前组件时，会执行 <code>initComputed</code> 方法初始化计算属性</p><p><strong>首先</strong>，该方法中，首先遍历用户写的计算属性</p><p>拿到计算 fullname 属性的方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性的多种写法： 直接写function /  完整写法,包含get、set</span></span><br><span class="line"><span class="keyword">const</span> getter = <span class="title function_">isFunction</span>(userDef) ? userDef : userDef.<span class="property">get</span></span><br></pre></td></tr></table></figure><p><strong>然后</strong>，会进行实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line">watchers[key] = <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br></pre></td></tr></table></figure><p>new Watcher 时，传入 getter 方法，并传入 <strong>lazy: true</strong> 表示该 watcher 是 <strong>computed watcher</strong></p><h3 id="2-1-3-重新劫持计算属性的-get"><a href="#2-1-3-重新劫持计算属性的-get" class="headerlink" title="2.1.3 重新劫持计算属性的 get"></a>2.1.3 重新劫持计算属性的 get</h3><p>createComputedGetter 方法重新定义了计算属性的 get</p><p>当计算属性 fullname  求值时，会走这里</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComputedGetter</span>(<span class="params">key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">computedGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="comment">// 求新值</span></span><br><span class="line">      <span class="keyword">if</span> (watcher.<span class="property">dirty</span>) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 让计算属性中依赖的属性 也去收集上一层watcher</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__ &amp;&amp; <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="property">onTrack</span>) &#123;</span><br><span class="line">          <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">onTrack</span>(&#123;</span><br><span class="line">            <span class="attr">effect</span>: <span class="title class_">Dep</span>.<span class="property">target</span>,</span><br><span class="line">            <span class="attr">target</span>: <span class="variable language_">this</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        watcher.<span class="title function_">depend</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dirty"><a href="#dirty" class="headerlink" title="dirty"></a>dirty</h4><p>计算属性使用 dirty 属性来标记该数据是否是脏数据</p><p>如果是脏数据，需要重新计算值</p><p>否则可以直接使用旧值</p><p>dirty 默认为 true，因此第一次取值，会进入 watcher.evaluate()</p><h4 id="watcher-evaluate"><a href="#watcher-evaluate" class="headerlink" title="watcher.evaluate()"></a>watcher.evaluate()</h4><p>evaluate() 方法很简单</p><p>首先使用 watcher 用来求值的通用方法： <strong>get()</strong> （计算属性入栈、求值、出栈）</p><p>然后将 dirty 标记：不是脏数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">evaluate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="watcher-depend"><a href="#watcher-depend" class="headerlink" title="watcher.depend()"></a>watcher.depend()</h4><p>让 <strong>计算属性watcher中依赖的属性</strong> 也去收集栈中的其他watcher</p><p>它会遍历当前 computed watcher 的deps属性，依次执行 dep 的 depend 方法</p><h1 id="3-举个栗子"><a href="#3-举个栗子" class="headerlink" title="3 举个栗子"></a>3 举个栗子</h1><h2 id="3-1-初始化"><a href="#3-1-初始化" class="headerlink" title="3.1 初始化"></a>3.1 初始化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">模板：</span><br><span class="line">&#123;&#123; fullname &#125;&#125;</span><br><span class="line"></span><br><span class="line">定义计算属性：</span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    fullname () &#123; </span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstname</span> + <span class="variable language_">this</span>.<span class="property">lastname</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.</p><p>首先，组件初始化时，已经有一个 <strong>render watcher</strong> 了。</p><p>.</p><p><strong>然后，实例化一个 computed watcher：</strong></p><p>因为 dirty 默认为 true，会进入 watcher.evaluate() 方法</p><p>使用 watcher 用来求值的通用方法：<strong>get()</strong></p><p>计算属性入栈：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure><p><strong>求值：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br></pre></td></tr></table></figure><p>因为是 computed watcher， 所以 this.getter 是传来的求值函数，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fullname () &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstname</span> + <span class="variable language_">this</span>.<span class="property">lastname</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 this 指向问题，使用 call 改变指向</p><p>求得的值，保存在 <strong>value</strong></p><p>计算属性出栈：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">popTarget</span>()</span><br></pre></td></tr></table></figure><p>.</p><p><strong>将 dirty 置为 false</strong></p><p>如果下次又触发了这个计算属性的 getter 会直接跳过求值逻辑</p><p>.</p><p><strong>调用 watcher.depend()</strong></p><p>让 <strong>计算属性watcher中的属性</strong> 也去收集 <strong>render watcher</strong></p><p>它会遍历当前 computed watcher 的deps属性，依次执行 dep 的 depend 方法</p><h2 id="3-2-依赖的属性发生变化"><a href="#3-2-依赖的属性发生变化" class="headerlink" title="3.2 依赖的属性发生变化"></a>3.2 依赖的属性发生变化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm.<span class="property">firstname</span> = <span class="string">&#x27;新值&#x27;</span>;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>只有当计算属性的依赖项被修改时，计算属性才会重新进行计算，生成一个新的值，而视图中其他变量被修改导致视图更新时，计算属性不会重新计算，这是怎么做到的呢？</p><p>当计算属性的依赖项，即 firstName 和 lastName 被修改时，数据劫持会触发内部的 setter，执行 watcher 的 <strong>update</strong></p><p><strong>通过前面的 <code>evaluate</code> 和 <code>depend</code> 方法，firstName 和 lastName 内部的 dep 中都会保存 2 个 watcher，一个 computed watcher，一个 render watcher</strong></p><div align="center">    <img src="/2023/07/23/Vue2源码：计算属性原理/photo1.png" style="height: 250px; width: 500px;"></div><p><strong>所以，首先会执行 computed watcher</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">      <span class="comment">// 将 dirty 标记为脏数据</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>属于计算属性watcher， lazy 为 true</p><p>因此会将 dirty 标记为脏数据</p><p><strong>可以看到，computed watcher就做了这么一个简单的事情，将  dirty 标记为脏数据</strong></p><p>而<strong>真正的求值操作是在 render watcher 中进行的：</strong></p><p>执行 render watcher 时</p><p>由于视图依赖了 fullName，会触发计算属性重新定义的 getter，执行前面的 createComputedGetter</p><p><strong>由于 dirty 为 true 脏数据</strong>，则会进行求值逻辑：watcher.evaluate()</p><p>此时 fullName 就拿到了最新的值了</p><h2 id="3-3-非依赖的属性发生变化"><a href="#3-3-非依赖的属性发生变化" class="headerlink" title="3.3 非依赖的属性发生变化"></a>3.3 非依赖的属性发生变化</h2><p>如果我修改的是与 fullname 无关的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">otherTimes</span> = <span class="string">&#x27;新值&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为这个属性不会触发计算watcher的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">lazy</span>) &#123;</span><br><span class="line">  <span class="comment">// 将 dirty 标记为脏数据</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 dirty 为 false，所以 fullname 不会重新执行计算新值的方法：watcher.evaluate()</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>创建一个力导向气泡图</title>
      <link href="/2023/07/14/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8A%9B%E5%AF%BC%E5%90%91%E6%B0%94%E6%B3%A1%E5%9B%BE/"/>
      <url>/2023/07/14/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8A%9B%E5%AF%BC%E5%90%91%E6%B0%94%E6%B3%A1%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-先上效果"><a href="#1-先上效果" class="headerlink" title="1 先上效果"></a>1 先上效果</h1><p><a href="https://postimg.cc/7J2tS4Z1"><img src="https://i.postimg.cc/KjqXSvXW/bubb.gif" alt="bubb.gif"></a></p><p>可以看到效果涉及：</p><ul><li>节点样式</li><li>力作用聚拢</li><li>节点交互事件</li></ul><p>下面来看看是怎样实现的</p><h1 id="2-数据格式"><a href="#2-数据格式" class="headerlink" title="2 数据格式"></a>2 数据格式</h1><h3 id="nodes-节点"><a href="#nodes-节点" class="headerlink" title="nodes 节点"></a>nodes 节点</h3><table><thead><tr><th>key</th><th>value</th></tr></thead><tbody><tr><td>id</td><td>唯一id</td></tr><tr><td>label</td><td>标签文本</td></tr><tr><td>style</td><td>节点样式，如：fill(填充色)、stroke(边缘颜色)、shadowBlur、shadowOffsetX、shadowOffsetY、shadowColor….</td></tr><tr><td>description</td><td>描述文本（放大后显示）</td></tr><tr><td>x</td><td>节点初始位置</td></tr><tr><td>y</td><td>节点初始位置</td></tr><tr><td>size</td><td>节点大小</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">        <span class="attr">nodes</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;iCheng&#x27;</span>,</span><br><span class="line">            <span class="attr">style</span>: &#123; <span class="attr">fill</span>: <span class="string">&#x27;l(0) 0:#ffffff 0.5:#8FE9FF 1:#87EAEF&#x27;</span>, <span class="attr">stroke</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">shadowBlur</span>: <span class="number">60</span>, <span class="attr">shadowOffsetX</span>: <span class="number">10</span>, <span class="attr">shadowOffsetY</span>: <span class="number">10</span>, <span class="attr">shadowColor</span>: <span class="string">&#x27;#ADD8E6&#x27;</span> &#125;,</span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;See the latest updates to the MDN reference pages about JavaScript regular expressions&#x27;</span>,</span><br><span class="line">            <span class="attr">x</span>: <span class="number">624.0361181340486</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">208.12272169694995</span>,</span><br><span class="line">            <span class="attr">size</span>: <span class="number">57</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="attr">label</span>: <span class="string">&#x27;analyse&#x27;</span>,</span><br><span class="line">            <span class="attr">style</span>: &#123; <span class="attr">fill</span>: <span class="string">&#x27;l(0) 0:#FFD3C9 0.5:#FFD3C9 1:#ffffff&#x27;</span>, <span class="attr">stroke</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">shadowBlur</span>: <span class="number">60</span>, <span class="attr">shadowOffsetX</span>: <span class="number">10</span>, <span class="attr">shadowOffsetY</span>: <span class="number">10</span>, <span class="attr">shadowColor</span>: <span class="string">&#x27;#E6E6FA&#x27;</span> &#125;,</span><br><span class="line">            <span class="attr">description</span>: <span class="string">&#x27;Learn what HTML landmark roles are, how they improve accessibility&#x27;</span>,</span><br><span class="line">            <span class="attr">x</span>: <span class="number">538.8142691877796</span>,</span><br><span class="line">            <span class="attr">y</span>: <span class="number">236.54991963171793</span>,</span><br><span class="line">            <span class="attr">size</span>: <span class="number">78</span></span><br><span class="line">          &#125;</span><br><span class="line">        ],</span><br><span class="line">    <span class="comment">// 本示例不需要边</span></span><br><span class="line">        <span class="attr">edges</span>: [],</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p>填充色使用渐变色</p><p><strong>描边线性渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 渐变角度为 <span class="number">0</span>，渐变的起始点颜色 <span class="selector-id">#ffffff</span>，中点的渐变色为 <span class="selector-id">#7ec2f3</span>，结束的渐变色为 <span class="selector-id">#1890ff</span></span><br><span class="line">&#x27;l(<span class="number">0</span>) <span class="number">0</span>:<span class="number">#ffffff</span> <span class="number">0.5</span>:<span class="number">#7ec2f3</span> <span class="number">1</span>:<span class="number">#1890ff</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>填充环形渐变</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 渐变起始圆的圆心坐标为被填充物体的包围盒中心点，半径为(包围盒对角线长度 / <span class="number">2</span>) 的 <span class="number">0.1</span> 倍，渐变的起始点颜色 <span class="selector-id">#ffffff</span>，中点的渐变色为 <span class="selector-id">#7ec2f3</span>，结束的渐变色为 <span class="selector-id">#1890ff</span></span><br><span class="line">&#x27;l(<span class="number">0</span>) <span class="number">0</span>:<span class="number">#ffffff</span> <span class="number">0.5</span>:<span class="number">#7ec2f3</span> <span class="number">1</span>:<span class="number">#1890ff</span><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="3-图配置"><a href="#3-图配置" class="headerlink" title="3 图配置"></a>3 图配置</h1><p>基于G6</p><p>Graph 是 G6 图表的载体，所有的 G6 节点实例操作以及事件，行为监听都在 Graph 实例上进行</p><p>Graph 的初始化通过 new 进行实例化，实例化时需要传入需要的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> width = container.<span class="property">scrollWidth</span>;</span><br><span class="line"><span class="keyword">const</span> height = (container.<span class="property">scrollHeight</span> || <span class="number">1000</span>) - <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> graph = <span class="keyword">new</span> <span class="variable constant_">G6</span>.<span class="title class_">Graph</span>(&#123;</span><br><span class="line">    <span class="attr">container</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">    width,</span><br><span class="line">    height,</span><br><span class="line">    <span class="comment">// 布局配置</span></span><br><span class="line">    <span class="attr">layout</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;force&#x27;</span>, <span class="comment">// 力导向布局</span></span><br><span class="line">      <span class="attr">nodeStrength</span>: <span class="number">300</span>, <span class="comment">// 节点作用力，正数代表节点之间的引力作用，负数代表节点之间的斥力作用</span></span><br><span class="line">      <span class="attr">collideStrength</span>: <span class="number">0.7</span>, <span class="comment">// 防止重叠的力强度，范围 [0, 1]</span></span><br><span class="line">      <span class="attr">alphaDecay</span>: <span class="number">0.01</span>, <span class="comment">// 迭代阈值的衰减率</span></span><br><span class="line">      <span class="attr">preventOverlap</span>: <span class="literal">true</span>, <span class="comment">// 是否防止重叠 必须在数据中设置了 size 或在该布局中配置了与当前图节点大小相同的 nodeSize 值</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">modes</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: [<span class="string">&#x27;collapse-expand-combo&#x27;</span>], <span class="comment">// combo类型</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 默认状态下节点的配置，比如 type, size, color。会被写入的 data 覆盖</span></span><br><span class="line">    <span class="attr">defaultNode</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bubble&#x27;</span>,</span><br><span class="line">      <span class="attr">size</span>: <span class="number">80</span>,</span><br><span class="line">      <span class="attr">labelCfg</span>: &#123;</span><br><span class="line">        <span class="attr">position</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">          <span class="attr">fill</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">          <span class="attr">fontSize</span>: <span class="number">6</span>,</span><br><span class="line">          <span class="attr">fontStyle</span>: <span class="string">&#x27;bold&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="3-1-Force-力导向"><a href="#3-1-Force-力导向" class="headerlink" title="3.1 Force 力导向"></a>3.1 Force 力导向</h2><p>Force 布局采用经典的力导向布局方法，将根据节点的信息，施加力使节点尽可能聚集</p><p>更多配置可查看文档：<a href="https://g6.antv.antgroup.com/api/graph-layout/combo-force">https://g6.antv.antgroup.com/api/graph-layout/combo-force</a></p><h1 id="4-节点交互事件"><a href="#4-节点交互事件" class="headerlink" title="4 节点交互事件"></a>4 节点交互事件</h1><h2 id="4-1-节点开始被拖拽-node-dragstart"><a href="#4-1-节点开始被拖拽-node-dragstart" class="headerlink" title="4.1 节点开始被拖拽 node:dragstart"></a>4.1 节点开始被拖拽 node:dragstart</h2><p>当节点开始被拖拽的时候触发的事件</p><p>节点开始被拖拽时，触发 <strong>refreshDragedNodePosition</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="title function_">on</span>(<span class="string">&#x27;node:dragstart&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    graph.<span class="title function_">layout</span>(); <span class="comment">// graph.layout()重新以当前配置的属性进行一次布局</span></span><br><span class="line">    <span class="title function_">refreshDragedNodePosition</span>(e);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="4-2-更新节点位置信息-refreshDragedNodePosition"><a href="#4-2-更新节点位置信息-refreshDragedNodePosition" class="headerlink" title="4.2 更新节点位置信息 refreshDragedNodePosition"></a>4.2 更新节点位置信息 refreshDragedNodePosition</h2><p>跟随拖动的位置，做相应数据处理</p><p><strong>参数e：</strong>鼠标拖动信息（包含节点 x、y 坐标信息）</p><p><strong>这个方法，会拿到节点当前x、y坐标值，赋予其 fx、fy 属性</strong></p><h3 id="fx、fy"><a href="#fx、fy" class="headerlink" title="fx、fy"></a>fx、fy</h3><p>当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 <strong>fx</strong> 与 <strong>fy</strong> 作为固定的坐标</p><p>如果将 <strong>fx</strong> 与  <strong>fy</strong> 置为空，该节点就会继续受力的作用而聚拢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">refreshDragedNodePosition</span> (e) &#123;</span><br><span class="line">  <span class="comment">// console.log(e)</span></span><br><span class="line">  <span class="keyword">const</span> model = e.<span class="property">item</span>.<span class="title function_">get</span>(<span class="string">&#x27;model&#x27;</span>);</span><br><span class="line">  model.<span class="property">fx</span> = e.<span class="property">x</span>;</span><br><span class="line">  model.<span class="property">fy</span> = e.<span class="property">y</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-拖动过程中-node-drag"><a href="#4-3-拖动过程中-node-drag" class="headerlink" title="4.3 拖动过程中 node:drag"></a>4.3 拖动过程中 node:drag</h2><p>当节点在拖动过程中时触发的事件</p><p>触发 <strong>refreshDragedNodePosition</strong> 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="title function_">on</span>(<span class="string">&#x27;node:drag&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="title function_">refreshDragedNodePosition</span>(e);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="4-4-拖拽完成后-node-dragend"><a href="#4-4-拖拽完成后-node-dragend" class="headerlink" title="4.4 拖拽完成后 node:dragend"></a>4.4 拖拽完成后 node:dragend</h2><p><strong>当拖拽完成后触发的事件</strong></p><p>将 <strong>fx</strong> 与  <strong>fy</strong> 置为空，该节点就会继续受力的作用而聚拢</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="title function_">on</span>(<span class="string">&#x27;node:dragend&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  e.<span class="property">item</span>.<span class="title function_">get</span>(<span class="string">&#x27;model&#x27;</span>).<span class="property">fx</span> = <span class="literal">null</span>;</span><br><span class="line">  e.<span class="property">item</span>.<span class="title function_">get</span>(<span class="string">&#x27;model&#x27;</span>).<span class="property">fy</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-5-点击事件-node-click"><a href="#4-5-点击事件-node-click" class="headerlink" title="4.5 点击事件 node:click"></a>4.5 点击事件 node:click</h2><p>当节点被点击时触发的事件</p><p>通过重置 <strong>size</strong> 属性，改变节点大小</p><p>重置 <strong>label</strong> 属性，改变节点的文本</p><p>再调用 <strong>graph.layout()</strong> 重新以当前配置的属性进行一次布局</p><div align="center">    <img src="/2023/07/14/创建一个力导向气泡图/bubb2.png" style="height: 250px; width: 500px;"></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="title function_">on</span>(<span class="string">&#x27;node:click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// debugger;</span></span><br><span class="line">  <span class="keyword">const</span> node = e.<span class="property">item</span>; <span class="comment">//拿到当前点击的节点</span></span><br><span class="line">  <span class="keyword">const</span> states = node.<span class="title function_">getStates</span>(); <span class="comment">//返回当前元素的所有状态 啥也没有</span></span><br><span class="line">  <span class="keyword">let</span> clicked = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> model = node.<span class="title function_">getModel</span>(); <span class="comment">// 获得节点位置</span></span><br><span class="line">  <span class="keyword">let</span> size = <span class="number">200</span>; <span class="comment">// 点击后的大小</span></span><br><span class="line">  <span class="keyword">let</span> labelText = <span class="string">&#x27;NODE: &#x27;</span> + model.<span class="property">id</span> + <span class="string">&#x27;\n&#x27;</span> + model.<span class="property">description</span>; <span class="comment">// 拼接： &quot;NODE:  this is node 8, and the value of it is 21&quot;</span></span><br><span class="line">  states.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">state</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;click&#x27;</span>) &#123;</span><br><span class="line">      clicked = <span class="literal">true</span>;</span><br><span class="line">      size = model.<span class="property">oriSize</span>;</span><br><span class="line">      labelText = model.<span class="property">oriLabel</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  graph.<span class="title function_">setItemState</span>(node, <span class="string">&#x27;click&#x27;</span>, !clicked); <span class="comment">//设置元素状态(元素实例，状态值，是否启用状态)</span></span><br><span class="line">  <span class="comment">// 更新元素，包括更新数据、样式等</span></span><br><span class="line">  graph.<span class="title function_">updateItem</span>(node, &#123;</span><br><span class="line">    size,</span><br><span class="line">    <span class="attr">label</span>: labelText,</span><br><span class="line">  &#125;);</span><br><span class="line">  graph.<span class="title function_">layout</span>(); <span class="comment">// graph.layout()重新以当前配置的属性进行一次布局</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="5-初始化图数据"><a href="#5-初始化图数据" class="headerlink" title="5 初始化图数据"></a>5 初始化图数据</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph.<span class="title function_">data</span>(data); <span class="comment">// 初始化图数据，data是一个包括 节点 数组和 边 数组的对象</span></span><br><span class="line">graph.<span class="title function_">render</span>();</span><br></pre></td></tr></table></figure><h2 id="6-执行时机"><a href="#6-执行时机" class="headerlink" title="6 执行时机"></a>6 执行时机</h2><p>因为要操作 DOM，因此上述 JS 代码在 <strong>mounted()</strong> 调用</p>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(4)：diff 算法原理</title>
      <link href="/2023/07/12/Vue2%E6%BA%90%E7%A0%81%EF%BC%9Adiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/12/Vue2%E6%BA%90%E7%A0%81%EF%BC%9Adiff%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1 是什么"></a>1 是什么</h1><p>如果我现在修改了模板中的一个属性</p><p>那么 Vue 怎么更新渲染处理比较好呢？</p><ul><li>把旧的 DOM 全部删除，然后渲染一个新的 DOM 替换上去？</li></ul><p>这样显然成本比较高</p><p>为了节省开销，Vue 中会<strong>将新老虚拟DOM进行对比，尽量复用旧 DOM</strong></p><p>这个过程就是 diff 算法</p><p>下面我们按照这个思路图，进行讲解</p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/流程图.png" style="height: 450px; width: 900px;"></div><h1 id="2-patch"><a href="#2-patch" class="headerlink" title="2 patch()"></a>2 patch()</h1><blockquote><p>源码位置：vue-main\src\core\vdom\patch.ts</p></blockquote><p>当数据更新，数据劫持，触发setter，派发更新，然后会执行 <strong>patch()</strong> 方法，会传入参数：<strong>老的虚拟节点、新的虚拟节点</strong></p><p>首先，这里面会执行 <strong>sameVnode()</strong> ，判断当前两个节点<strong>是否是同类标签</strong></p><ul><li>不是同类标签：那就直接替换就完事了</li><li>是同类标签：就要进行进一步比较，看看他俩是不是完全一样的，调用 <strong>patchVnode()</strong> 方法</li></ul><h2 id="2-1-sameVnode-是否是同类标签"><a href="#2-1-sameVnode-是否是同类标签" class="headerlink" title="2.1 sameVnode() 是否是同类标签"></a>2.1 sameVnode() 是否是同类标签</h2><p> sameVnode() 的作用是：通过对比 key、tag、inputType 判断当前两个节点是否是同类标签</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sameVnode</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.<span class="property">key</span> === b.<span class="property">key</span> &amp;&amp;</span><br><span class="line">    a.<span class="property">asyncFactory</span> === b.<span class="property">asyncFactory</span> &amp;&amp;</span><br><span class="line">    ((a.<span class="property">tag</span> === b.<span class="property">tag</span> &amp;&amp;</span><br><span class="line">      a.<span class="property">isComment</span> === b.<span class="property">isComment</span> &amp;&amp;</span><br><span class="line">      <span class="title function_">isDef</span>(a.<span class="property">data</span>) === <span class="title function_">isDef</span>(b.<span class="property">data</span>) &amp;&amp;</span><br><span class="line">      <span class="title function_">sameInputType</span>(a, b)) ||</span><br><span class="line">      (<span class="title function_">isTrue</span>(a.<span class="property">isAsyncPlaceholder</span>) &amp;&amp; <span class="title function_">isUndef</span>(b.<span class="property">asyncFactory</span>.<span class="property">error</span>)))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-patchVnode"><a href="#3-patchVnode" class="headerlink" title="3 patchVnode()"></a>3 patchVnode()</h1><ul><li>文本不同则覆盖文本</li><li>旧虚拟 DOM 多余子节点，则删除；</li><li>旧虚拟 DOM 少子节点，则新增</li><li>都有子节点，进行 updateChildren() 比较两个人的子节点</li></ul><h1 id="4-updateChildren-diff-核心方法"><a href="#4-updateChildren-diff-核心方法" class="headerlink" title="4 updateChildren() - diff 核心方法"></a>4 updateChildren() - diff 核心方法</h1><p><code>updateChildren</code> 是核心，采用双指针的方式，比较<strong>旧虚拟 DOM</strong> 和<strong>新虚拟 DOM</strong> 的<strong>子节点</strong>，尽量复用旧虚拟 DOM </p><p><strong>while 循环：</strong></p><p>因为循环过程中有<strong>两个指针</strong>指向新、旧DOM，因此while循环条件是当前遍历的index没有越界</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx)</span><br></pre></td></tr></table></figure><p><strong>头头比较：</strong></p><ul><li>指针指向：<strong>oldStartVnode, newStartVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>index++</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/头头比较.png" style="height: 550px; width: 600px;"></div><p><strong>尾尾比较：</strong></p><ul><li>指针指向：<strong>oldEndVnode, newEndVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>index - -</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/尾尾比较.png" style="height: 550px; width: 760px;"></div><p><strong>头尾比较：</strong></p><ul><li>指针指向：<strong>oldStartVnode, newEndVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>旧节点 index++   新节点 index–</li></ul><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/头尾比较.png" style="height: 350px; width: 760px;"></div><p><strong>尾头比较：</strong></p><ul><li>指针指向：<strong>oldEndVnode, newStartVnode</strong></li><li>sameVnode() 方法比较他们是否是相同节点，为 true 才会进行下面</li><li>调用 patchVnode() 递归比较</li><li>旧节点 index–   新节点 index++</li></ul><p><strong>乱序比较：</strong></p><p>根据老的索引和key做一个映射关系 </p><p>根据新虚拟节点的去寻找</p><p>找到则移动到前面（移动过的标识为undefined）</p><p>找不到则添加</p><p>最后多余的就删除</p><p><strong>跳出while循环</strong></p><p>如果旧节点没有，新节点有</p><p>就要把多余的节点就插入到老的</p><p>那么这里有两种情况：</p><ul><li>头头比较，可以直接把<strong>多余的节点插入 old节点 后面</strong>   </li><li>尾尾比较：需要把<strong>多余的节点插入 old节点 前面</strong></li></ul><p>一个要插入前面、一个要插入后面，所以 Vue 中使用<strong>获取下一个元素方法</strong>来解决：</p><ul><li>拿到这个多余节点的<strong>下一个元素</strong>，可能为空(头头比较情况)，可能存在(尾尾比较情况)</li><li>执行 el.insertBefore(真实节点, 下一个元素)  <ul><li>如果下一个元素为空：就是<strong>头头比较</strong>的情况，则相当于appendChild() ，在<strong>老节点后面追加</strong>多余的节点</li><li>如果不为空：就是<strong>尾尾比较</strong>情况，在老节点中找到<strong>此下一个元素</strong>，要到会把多余节点<strong>插入到下一个元素的前面</strong></li></ul></li></ul><p>至此 diff 算法完成</p><p><strong>不过这里还涉及到一个面试题</strong></p><h1 id="5-面试题"><a href="#5-面试题" class="headerlink" title="5 面试题"></a>5 面试题</h1><h3 id="5-1-面试题：为什么v-for循环时，key不能使用索引？"><a href="#5-1-面试题：为什么v-for循环时，key不能使用索引？" class="headerlink" title="5.1 面试题：为什么v-for循环时，key不能使用索引？"></a>5.1 面试题：为什么v-for循环时，key不能使用索引？</h3><p>如下图，如果当前有一个数组存储：[‘苹果’, ‘梨’, ‘香蕉’]</p><p>使用 v-for 循环，渲染到页面上</p><p>并将苹果置为<strong>被勾选状态</strong></p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/面试题1.png" style="height: 250px; width: 500px;"></div><p><strong>如果现在使用 索引 作为 key</strong></p><p>用户向数组中 unshift 一个火龙果</p><p>那么界面，就变成了火龙果被勾选的状态</p><p>这是为什么？？</p><h3 id="5-2-原因"><a href="#5-2-原因" class="headerlink" title="5.2 原因"></a>5.2 原因</h3><p>因为修改数据后，虚拟DOM转换为真实DOM过程的 diff 算法</p><p>sameVnode() 采用 key、tag、inputType 判断是否是同类标签</p><p>之前苹果的索引为0</p><p>插入火龙果后，火龙果的索引依然是0</p><p>此时 sameVnode() 判断两个节点是同类标签，进一步比较 patchVnode()，<strong>仅使用新文本替换旧文本</strong></p><p>勾选状态还在</p><p>所以火龙果就被勾选了</p><div align="center">    <img src="/2023/07/12/Vue2源码：diff算法原理/面试题2.png" style="height: 750px; width: 760px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(3)：依赖收集 派发更新</title>
      <link href="/2023/07/11/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0/"/>
      <url>/2023/07/11/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%20%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-What"><a href="#1-What" class="headerlink" title="1 What"></a>1 What</h1><p>程序在运行时，状态会不断发生变化。当状态发生变化后，需要重新渲染，得到最新的视图。</p><p>正是<strong>响应式</strong>赋予了<strong>状态变更 - 重新渲染</strong>的能力</p><p>通常来说，响应式的核心组成部分为：<strong>数据劫持、依赖收集、派发更新</strong></p><p>之前一篇文章已经叙述过数据劫持的内容</p><blockquote><p>数据劫持源码分析：<a href="https://icheng.github.io/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/">https://icheng.github.io/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/</a></p></blockquote><p>下面来分析一下依赖收集、派发更新的源码原理</p><h1 id="2-思考-3-个问题"><a href="#2-思考-3-个问题" class="headerlink" title="2 思考 3 个问题"></a>2 思考 3 个问题</h1><p>我们知道了 Vue2 底层是通过 <code>Object.defineProperty</code> 来实现数据响应式的，但是单有这个还不够，因为数据可能没有在模板中使用</p><p>所以 Vue2，通过<strong>依赖收集</strong>来判断哪些用到的数据的变更需要触发视图更新，再通过<strong>派发更新</strong>通知视图进行更新渲染</p><p><strong>那么我们先来考虑 3 个问题：</strong></p><ul><li>依赖是谁？换句话说，属性发生变化后，通知到谁？（Watcher）</li><li>依赖收集到哪里？每一个数据的依赖都需要集中管理（Dep）</li><li>在哪里做依赖收集？（Observe）</li></ul><h2 id="3-依赖收集中的各个类"><a href="#3-依赖收集中的各个类" class="headerlink" title="3 依赖收集中的各个类"></a>3 依赖收集中的各个类</h2><p>先来看一张图</p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/原理图.jpg" style="height: 400px; width: 900px;"></div><p>数据是<strong>被观察者</strong>，将数据标记为已观测数据后，数据就会有一个 Dep 实例</p><p>触发数据的 getter 时，就会进行依赖收集，将依赖集中管理</p><p>触发数据的 setter 时，就会进行派发更新，会通知 <strong>观察者Watcher</strong> 进行渲染更新</p><p>带着这张图，我们来分析一下过程中的 3 个类： Watcher、Dep、Observe</p><h2 id="3-1-Dep"><a href="#3-1-Dep" class="headerlink" title="3.1 Dep"></a>3.1 Dep</h2><blockquote><p>源码位置：vue-main\src\core\observer\dep.ts</p></blockquote><p>每一个被观测的数据都会有一个 <code>Dep</code> 类实例，且 Dep 拥有一个唯一 id</p><h4 id="subs-队列"><a href="#subs-队列" class="headerlink" title="subs 队列"></a>subs 队列</h4><p>Dep 内部维护一个 <strong>subs</strong> 队列</p><p>subs就是subscribers的意思，保存着依赖本数据的<strong>观察者 Watcher</strong></p><h4 id="Dep-target"><a href="#Dep-target" class="headerlink" title="Dep.target"></a>Dep.target</h4><p>全局变量，指向目前正在使用的 watcher</p><ul><li><strong>targetStack</strong>：栈结构，用来保存Watcher</li><li><strong>pushTarget</strong>：往 targetStack 中 push 当前的 Watcher（排在前一个Watcher的后面），并把  Dep.target  赋值给当前 Watcher</li><li><strong>popTarget</strong>：先把 targetStack 最后一个元素弹出(.pop)，再把 Dep.target 赋值给最后一个Watcher(也就是还原了前一个Watcher)</li><li>通过上述实现，vue 保证了 全局唯一的 Watcher，准确赋值在 Dep.target 中</li></ul><h4 id="dep-depend"><a href="#dep-depend" class="headerlink" title="dep.depend()"></a>dep.depend()</h4><p>Dep 类中有个一个 depend() 方法，进行<strong>依赖收集</strong></p><p>但他不会直接将 watcher 存放在 subs 中</p><p>而是调用 <code>Dep.target.addDep()</code> ：</p><p>通知 watcher 先存放 dep （去重）</p><p>再调用 <code>dep.addSub()</code> 让 dep 存储该 watcher</p><p><strong>这样便完成了双向存储，并且不会重复存储</strong></p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/dep1.png" style="height: 230px; width: 300px;"></div><h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify()"></a>dep.notify()</h4><p>触发数据劫持的 setter 时会执行这个 dep.notify() </p><p>会遍历 subs</p><p>通知 watcher 执行  <code>.update()</code> 方法 去<strong>派发更新</strong></p><h2 id="3-2-Watcher"><a href="#3-2-Watcher" class="headerlink" title="3.2 Watcher"></a>3.2 Watcher</h2><p>观察者，拥有一个唯一id</p><p>同时要注意的是，watcher有三种：render watcher、 computed watcher (lazy为true)、user watcher (user为true)</p><h4 id="addDep"><a href="#addDep" class="headerlink" title="addDep()"></a>addDep()</h4><p>这个方法上面说过了，用来双向存储</p><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><p>派发更新</p><p>这里会进行判断：</p><p>如果 lazy 为 true，说明是计算属性，则将 dirty 设置为 true</p><p>或者就进行执行 <code>queueWatcher</code> 进行异步更新</p><blockquote><p>异步更新文章：</p><p><a href="https://icheng.github.io/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/">https://icheng.github.io/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/</a></p></blockquote><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p>update() 后，进入异步更新，异步更新的 flushSchedulerQueue() 还是会执行这个get()方法</p><ul><li>调用dep的pushTarget</li><li>调用回调函数（如渲染更新方法 <code>vm._update(vm._render())</code> ）</li><li>popTarget</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)  <span class="comment">// 调用函数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">user</span>) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="variable language_">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">deep</span>) &#123;</span><br><span class="line">        <span class="title function_">traverse</span>(value)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">popTarget</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-Observe-依赖收集的入口"><a href="#3-3-Observe-依赖收集的入口" class="headerlink" title="3.3 Observe 依赖收集的入口"></a>3.3 Observe 依赖收集的入口</h2><p>之前的文章讲过，Observer 会将数据标记<strong>已观测数据</strong></p><p>并通过 Object.defineProperty 的 get&#x2F;set 劫持数据的读取和修改</p><p>劫持数据 <code>getter</code> 时进行<strong>依赖收集</strong>，如果 <code>Dep.target</code> 存在，就调用 <code>dep.depend()</code></p><p>劫持数据 <code>setter</code> 时<strong>派发更新</strong>，调用 <code>dep.notify()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;</span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (!<span class="title function_">hasChanged</span>(value, newVal)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__DEV__ &amp;&amp; customSetter) &#123;</span><br><span class="line">        <span class="title function_">customSetter</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.<span class="title function_">call</span>(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (getter) &#123;</span><br><span class="line">        <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!shallow &amp;&amp; <span class="title function_">isRef</span>(value) &amp;&amp; !<span class="title function_">isRef</span>(newVal)) &#123;</span><br><span class="line">        value.<span class="property">value</span> = newVal</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal, <span class="literal">false</span>, mock)</span><br><span class="line">      <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>(&#123;</span><br><span class="line">          <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">SET</span>,</span><br><span class="line">          <span class="attr">target</span>: obj,</span><br><span class="line">          key,</span><br><span class="line">          <span class="attr">newValue</span>: newVal,</span><br><span class="line">          <span class="attr">oldValue</span>: value</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dep.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看到这里，是否细节太多绕晕了？</p><p><strong>来个初始化时的整体流程，从宏观角度再过一遍</strong></p><h1 id="3-初始化流程"><a href="#3-初始化流程" class="headerlink" title="3 初始化流程"></a>3 初始化流程</h1><p>比如我们在模板中使用 <code>&#123;&#123;name&#125;&#125;</code></p><p>组件挂载过程中，进行 new Watcher，创建一个渲染watcher</p><p>并传入参数：渲染更新方法 <code>vm._update(vm._render())</code></p><blockquote><p>源码位置：vue-main\src\core\instance\lifecycle.ts  （mountComponent）</p></blockquote><p>因为不是 computed  watcher ，会默认执行 get() 方法：</p><ul><li><p>pushTarget() ：当前 Dep.target 指向这个渲染watcher</p></li><li><p>调用回调函数，当前函数是渲染更新方法 <code>vm._update(vm._render())</code></p><p>首先 <code>vm._render()</code> 会去实例中取新值，这个过程则调用 <code>Object.defineProperty</code> 的 get，当前 <code>Dep.target</code> 是存在的，会执行 <code>dep.depend()</code> ，进行<strong>依赖收集</strong></p><p>那么 dep 和 watcher 的双向存储就完成了</p><p>然后 <code>vm._update()</code> 会将虚拟DOM转为真实DOM，涉及diff算法等等，总之渲染完成</p></li><li><p>popTarget()： Dep.target 不需要指向这个渲染watcher了</p></li><li><p>同时会存储目前的属性值，存储在value，方便后面判断值是否修改了</p></li></ul><p>看看源码：</p><blockquote><p>源码位置：vue-main\src\core\observer\watcher.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="property">lazy</span> ? <span class="literal">undefined</span> : <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/初始化流程.png" style="height: 230px; width: 580px;"></div><h1 id="4-修改值流程"><a href="#4-修改值流程" class="headerlink" title="4 修改值流程"></a>4 修改值流程</h1><p>那么修改值的过程，主要就是多了劫持getter和异步更新</p><div align="center">    <img src="/2023/07/11/Vue2源码：依赖收集 派发更新/修改值流程.png" style="height: 530px; width: 880px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(2)：数据劫持原理</title>
      <link href="/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/10/Vue2%E6%BA%90%E7%A0%81%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据劫持是什么"><a href="#1-数据劫持是什么" class="headerlink" title="1 数据劫持是什么"></a>1 数据劫持是什么</h1><p>Vue 最独特的特性之一，是其响应式系统。</p><p>而实现响应式的过程中，要实现<strong>数据劫持</strong>才能监听数据的变化</p><p>数据劫持就是：拦截属性的读取和修改，简单来说就是数据的任何变化都要能监测到，这样才能根据数据变化做对应操作</p><h1 id="2-数据劫持源码逻辑"><a href="#2-数据劫持源码逻辑" class="headerlink" title="2 数据劫持源码逻辑"></a>2 数据劫持源码逻辑</h1><h2 id="2-1-initState-初始化"><a href="#2-1-initState-初始化" class="headerlink" title="2.1 initState() 初始化"></a>2.1 initState() 初始化</h2><p>Vue 在执行完生命周期钩子函数 <code>beforeCreate</code> 之后，会根据配置项是否存在，执行对应的相应的初始化（如Props、methods、data、computed等等）</p><p><strong>如果 data 存在</strong></p><p>会执行 <code>initData()</code>，进行 data 数据初始化操作</p><p>下面进行 <code>initData()</code> 初始化的分析</p><p>这里的源码：</p><blockquote><p>vue-main\src\core\instance\state.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initState</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.<span class="property">$options</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">props</span>) <span class="title function_">initProps</span>(vm, opts.<span class="property">props</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Composition API</span></span><br><span class="line">  <span class="title function_">initSetup</span>(vm)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">methods</span>) <span class="title function_">initMethods</span>(vm, opts.<span class="property">methods</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//  data 数据初始化</span></span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">data</span>) &#123;</span><br><span class="line">    <span class="title function_">initData</span>(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="title function_">observe</span>((vm.<span class="property">_data</span> = &#123;&#125;))</span><br><span class="line">    ob &amp;&amp; ob.<span class="property">vmCount</span>++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">computed</span>) <span class="title function_">initComputed</span>(vm, opts.<span class="property">computed</span>)</span><br><span class="line">  <span class="keyword">if</span> (opts.<span class="property">watch</span> &amp;&amp; opts.<span class="property">watch</span> !== nativeWatch) &#123;</span><br><span class="line">    <span class="title function_">initWatch</span>(vm, opts.<span class="property">watch</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-initData-数据初始化"><a href="#2-2-initData-数据初始化" class="headerlink" title="2.2 initData()  数据初始化"></a>2.2 initData()  数据初始化</h2><p>进入 <code>initData()</code> ，<strong>主要做了 3 件事：</strong></p><p>1 首先就是<strong>判断 data 的类型</strong></p><ul><li>如果 data 是函数，就调用这个函数，返回数据</li><li>如果是对象，就可以使用这个对象</li></ul><blockquote><p>当然，我们知道 data 还是希望写成函数类型的：</p><p>因为数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的<code>data</code>，拥有自己的<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据</p><p>我们组件的date单纯的写成对象形式，这些实例用的是同一个构造函数，由于JavaScript的特性所导致，所有的组件实例共用了一个data，就会造成该组件的数据会被其他组件应影响</p></blockquote><p>2 如果methods、props 和 data 中没有重名的属性，就用 <strong>proxy 代理 data 中的属性到 vm 上</strong></p><p>即： <code>vm.name -&gt; vm._data.name</code></p><p>3 调用 <strong>observe() 进行数据劫持</strong>，这里就是数据劫持真正的开始</p><p>这部分的源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">initData</span>(<span class="params">vm: Component</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">data</span>: any = vm.<span class="property">$options</span>.<span class="property">data</span></span><br><span class="line">  data = vm.<span class="property">_data</span> = <span class="title function_">isFunction</span>(data) ? <span class="title function_">getData</span>(data, vm) : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isPlainObject</span>(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    __DEV__ &amp;&amp;</span><br><span class="line">      <span class="title function_">warn</span>(</span><br><span class="line">        <span class="string">&#x27;data functions should return an object:\n&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;https://v2.vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.<span class="property">$options</span>.<span class="property">props</span></span><br><span class="line">  <span class="keyword">const</span> methods = vm.<span class="property">$options</span>.<span class="property">methods</span></span><br><span class="line">  <span class="keyword">let</span> i = keys.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; <span class="title function_">hasOwn</span>(methods, key)) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(<span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; <span class="title function_">hasOwn</span>(props, key)) &#123;</span><br><span class="line">      __DEV__ &amp;&amp;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">            <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">isReserved</span>(key)) &#123;</span><br><span class="line">      <span class="title function_">proxy</span>(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  <span class="keyword">const</span> ob = <span class="title function_">observe</span>(data)</span><br><span class="line">  ob &amp;&amp; ob.<span class="property">vmCount</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-observe"><a href="#2-3-observe" class="headerlink" title="2.3 observe()"></a>2.3 observe()</h2><p>这里主要做一些规范处理。接下来主要列一些什么情况下数据会被标记为响应式，什么情况下不被响应式</p><ul><li>如果不是数组&#x2F;对象，则return，不继续执行；</li><li>如果该数据是 <code>Observer</code> 类的实例，则意味着当前属性已被标记为响应式数据，无需处理</li><li>return new Observer() 将其标记为响应式数据</li></ul><p>这部分的源码：</p><blockquote><p>vue-main\src\core\observer\index.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params"></span></span><br><span class="line"><span class="params">  value: any,</span></span><br><span class="line"><span class="params">  shallow?: boolean,</span></span><br><span class="line"><span class="params">  ssrMockReactivity?: boolean</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; <span class="title function_">hasOwn</span>(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.<span class="property">__ob__</span> <span class="keyword">instanceof</span> <span class="title class_">Observer</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.<span class="property">__ob__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    (ssrMockReactivity || !<span class="title function_">isServerRendering</span>()) &amp;&amp;</span><br><span class="line">    (<span class="title function_">isArray</span>(value) || <span class="title function_">isPlainObject</span>(value)) &amp;&amp;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(value) &amp;&amp;</span><br><span class="line">    !value.<span class="property">__v_skip</span> <span class="comment">/* ReactiveFlags.SKIP */</span> &amp;&amp;</span><br><span class="line">    !<span class="title function_">isRef</span>(value) &amp;&amp;</span><br><span class="line">    !(value <span class="keyword">instanceof</span> <span class="title class_">VNode</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value, shallow, ssrMockReactivity)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-Observer类"><a href="#2-4-Observer类" class="headerlink" title="2.4 Observer类"></a>2.4 Observer类</h2><p><code>Observer</code> 构造函数会真正的将数据标记为响应式</p><ul><li><p>首先给属性增加一个<strong>不可枚举的 <code>__ob__</code> 对象</strong> ，表明<strong>已被观测</strong> (为啥要不可枚举？为了不影响实际开发，比如 <code>for..in..</code> 循环的时候不遍历到 <code>__ob__</code> 属性)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)      <span class="comment">//给属性增加一个**不可枚举的 `__ob__` 对象**</span></span><br></pre></td></tr></table></figure></li><li><p>然后就是判断当前属性<strong>是数组还是对象</strong></p></li></ul><h3 id="2-4-1-如果是数组"><a href="#2-4-1-如果是数组" class="headerlink" title="2.4.1 如果是数组"></a>2.4.1 如果是数组</h3><h6 id="先对数组的每一项进行监测"><a href="#先对数组的每一项进行监测" class="headerlink" title="先对数组的每一项进行监测"></a>先对数组的每一项进行监测</h6><p><strong>调用 observeArray()</strong> ，遍历数组，对每一元素调用 <code>observe()</code> 方法继续监测数据</p><p>这里的源码：</p><blockquote><p>vue-main\src\core\observer\index.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">observeArray</span>(<span class="params">value: any[]</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(value[i], <span class="literal">false</span>, <span class="variable language_">this</span>.<span class="property">mock</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="拦截数组方法"><a href="#拦截数组方法" class="headerlink" title="拦截数组方法"></a>拦截数组方法</h6><blockquote><p>有些方法会修改数组本身，这些方法被称为<strong>变异方法</strong> （push、pop、shift、unshift、splice、sort、reverse）</p><p>当开发者调用这些方法修改<code>data</code>中的数组数据的时候，<code>Vue</code>需要及时得知并作出反应</p></blockquote><ul><li>首先，拿到数组的原型链<code>Array.prototype</code>，通过<code>Object.create</code> 复制一份</li></ul><blockquote><p>因为需要在数组原型上修改7个方法，但是直接修改会干掉原有的方法，我们需要用 <code>Object.create()</code> 拷贝一份数组原型出来，在复制出来的原型上面做功能扩展</p></blockquote><ul><li>然后，会调用原生数组方法（毕竟不能影响数组原本的功能）</li><li>关键在于代码中间部分，他会调用 <code>__ob__.dep</code> 的 <code>notify </code>方法去通知watcher，告诉对方：我有变化了，你快更新吧；</li><li>如果是能增加数组长度的 3 个方法 <code>push、unshift、splice</code> ，获取到插入的值，然后把新添加的值变成一个响应式对象（再次调用observeArray()）。</li></ul><p>这里的源码：</p><blockquote><p>vue-main\src\core\observer\array.ts</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="title class_">Object</span>.<span class="title function_">create</span>(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPatch.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">method</span>) &#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]  </span><br><span class="line">  <span class="title function_">def</span>(arrayMethods, method, <span class="keyword">function</span> <span class="title function_">mutator</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)   <span class="comment">// 调用原生数组方法</span></span><br><span class="line">    <span class="keyword">const</span> ob = <span class="variable language_">this</span>.<span class="property">__ob__</span></span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.<span class="title function_">slice</span>(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.<span class="title function_">observeArray</span>(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      ob.<span class="property">dep</span>.<span class="title function_">notify</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="title class_">TriggerOpTypes</span>.<span class="property">ARRAY_MUTATION</span>,</span><br><span class="line">        <span class="attr">target</span>: <span class="variable language_">this</span>,</span><br><span class="line">        <span class="attr">key</span>: method</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="vue为什么没有提供对数组属性的监听呢？"><a href="#vue为什么没有提供对数组属性的监听呢？" class="headerlink" title="vue为什么没有提供对数组属性的监听呢？"></a>vue为什么没有提供对数组属性的监听呢？</h4><p>既然 Object.defineProperty 有劫持getter，setter能力，那么 vue 为什么没用它来实现对数组属性的监听呢？</p><p>尤大在<a href="https://link.juejin.cn/?target=https://github.com/vuejs/vue/issues/8562">github</a>上这样回答：</p><div align="center">    <img src="/2023/07/10/Vue2源码：数据劫持原理/1.jpg" style="height: 850px; width: 600px;"></div><p>如果你知道数组的长度，理论上是可以预先给所有的索引设置 getter&#x2F;setter 的。但是一来很多场景下你不知道数组的长度，二来，如果是很大的数组，预先加 getter&#x2F;setter 性能负担较大。</p><p>总而言之就是理论上 Vue 是可以这样做，但是出于性能考虑没这样做，而是用了一种数组变异办法来触发视图更新。</p><h3 id="2-4-2-如果是对象"><a href="#2-4-2-如果是对象" class="headerlink" title="2.4.2 如果是对象"></a>2.4.2 如果是对象</h3><p>遍历对象的每个元素，执行 <code>defineReactive()</code> 方法逻辑如下:</p><p>首先 new Dep()，该 dep 在后面 get set 时都会使用这个<strong>闭包产生的 dep</strong>，这个时候就能明白了数据对象中每个数据字段都有属于自己的 <code>dep</code> 常量（这里涉及到依赖收集理念）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br></pre></td></tr></table></figure><p>接下来缓存原有描述属性中可能存在的 <code>get</code> 方法和 <code>set</code> 方法，分别缓存在变量 <code>getter</code>、<code>setter </code>中，为什么要缓存呢？主要是接下来会执行<code>Object.defineProperty  </code> 重新定义属性的 <code>getter/setter</code>，这会导致原有的 <code>get</code>、<code>set</code> 方法被重新覆盖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getter = property &amp;&amp; property.<span class="property">get</span></span><br><span class="line"><span class="keyword">const</span> setter = property &amp;&amp; property.<span class="property">set</span></span><br></pre></td></tr></table></figure><p>然后，默认会将对象进行深度劫持</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">observe</span>()</span><br></pre></td></tr></table></figure><p><strong>接下来我们看看拦截器的 <code>get</code> 方法都做了些啥：</strong></p><p>因为是读取属性，首先要确保不能影响正常逻辑，要调用前面缓存的 <code>getter</code>，拿到正确的返回结果</p><p>然后就是 <code>getter</code> 的主要使命，收集依赖：</p><p>若 <code>Dep.target</code> 存在，则执行<code>dep.depend()</code>。那么 <code>Dep.target</code> 是什么？其实就是 watcher</p><p>（依赖收集内容放到后面的文章讲）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val     <span class="comment">// 拿到正确的返回结果</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>(&#123;      <span class="comment">//依赖收集</span></span><br><span class="line">            <span class="attr">target</span>: obj,</span><br><span class="line">            <span class="attr">type</span>: <span class="title class_">TrackOpTypes</span>.<span class="property">GET</span>,</span><br><span class="line">            key</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">isRef</span>(value) &amp;&amp; !shallow ? value.<span class="property">value</span> : value</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p><strong>接下来我们看看拦截器的<code>set</code>方法都做了些啥：</strong></p><p><code>set </code> 函数主要做两件事:</p><ul><li><p>如果值改变了，调用缓存的 setter，为属性设置新值；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setter.<span class="title function_">call</span>(obj, newVal)</span><br></pre></td></tr></table></figure></li><li><p>通知 watcher 更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep.<span class="property">notify</span></span><br></pre></td></tr></table></figure></li></ul><p>这便是数据劫持的主要内容</p><p>想要理解它，还需要知道依赖收集中的 watcher、dep关系</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 JS 扩展 Markdown 语法</title>
      <link href="/2023/07/09/%E4%BD%BF%E7%94%A8%20JS%20%E6%89%A9%E5%B1%95%20Markdown%20%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/07/09/%E4%BD%BF%E7%94%A8%20JS%20%E6%89%A9%E5%B1%95%20Markdown%20%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h1><p>近期在使用 Hexo </p><p>用 Markdown 语法过程中</p><p>发现 Markdown 的原生语法<strong>无法设置图片的大小</strong></p><p>如官方推荐的引入图片方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure><p>无法设置图片大小，并且图片会默认靠左边</p><p>如果想要实现图片 <strong>水平居中 + 调节大小</strong></p><p>好像只能通过写 HTML + CSS</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;XXX.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;height: 500px; width: 600px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>怪麻烦的</p><p><strong>于是我用  JS 扩展了 Markdown 语法，通过更简单的方式实现图片的放大缩小 + 水平居中</strong></p><p>可以在 GIthub 上下载源码：</p><p><a href="https://github.com/iCheng/hexo_relayout_image">https://github.com/iCheng/hexo_relayout_image</a></p><h1 id="2-使用语法"><a href="#2-使用语法" class="headerlink" title="2 使用语法"></a>2 使用语法</h1><h2 id="2-1-GIthub-上下载源码后"><a href="#2-1-GIthub-上下载源码后" class="headerlink" title="2.1 GIthub 上下载源码后"></a>2.1 GIthub 上下载源码后</h2><p>将 hexo_relayout_image.js 文件移动至 public&#x2F;js&#x2F; 下</p><h2 id="2-2-增加-script-脚本"><a href="#2-2-增加-script-脚本" class="headerlink" title="2.2 增加 script 脚本"></a>2.2 增加 script 脚本</h2><p>进入你的主题下 layout 目录中的 layout.ejs 文件</p><blockquote><p>我用的主题是Cupertino：路径就是 &#x2F;themes&#x2F;Cupertino&#x2F;layout&#x2F;layout.ejs</p></blockquote><p>将下面的代码加入到 body 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 扩展语法 --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;&lt;%- config.root %&gt;js/hexo_relayout_image.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><div align="center">    <img src="/2023/07/09/使用 JS 扩展 Markdown 语法/脚本文件.png" style="height: 70px; width: 700px;"></div><h2 id="2-3-使用语法"><a href="#2-3-使用语法" class="headerlink" title="2.3 使用语法"></a>2.3 使用语法</h2><blockquote><p>Hexo 内部会将 <code>![](image.jpg)</code> 转为 <code>img</code> 标签格式</p><p>官网：<code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p></blockquote><p>我的扩充的语法格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="variable constant_">XXXX</span>.<span class="property">png</span>?<span class="number">700</span>&amp;<span class="number">500</span>)</span><br></pre></td></tr></table></figure><ul><li>在路径后使用 <strong>?</strong> 分隔</li><li>然后输入宽(width)、高(height)，并使用 <strong>&amp;</strong> 连接</li></ul><p>然后：</p><p>该图片将 <strong>按照设置的宽(width)、高(height)</strong> 重绘</p><p>并且该图片会 <strong>自动实现水平居中</strong></p><h1 id="3-效果"><a href="#3-效果" class="headerlink" title="3 效果"></a>3 效果</h1><p><img src="/%E6%95%88%E6%9E%9C.png?500&500"></p>]]></content>
      
      
      <categories>
          
          <category> 一点小想法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2源码(1)：nextTick原理</title>
      <link href="/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/"/>
      <url>/2023/07/08/Vue2%E6%BA%90%E7%A0%81%EF%BC%9AnextTick%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>nexttick源码</p><p>[TOC]</p><h1 id="1-nextTick-是什么"><a href="#1-nextTick-是什么" class="headerlink" title="1 nextTick 是什么"></a>1 nextTick 是什么</h1><p>由于 vue 中 DOM更新 是异步的</p><p>当你设置 <code>vm.someData = &#39;new value&#39;</code>，该数据不会立即重新渲染。</p><p>多数情况我们不需要关心这个过程，但是如果你要<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong>，就需要 nextTick 保证你的逻辑执行在<strong>完成更新 DOM之后</strong>了。</p><h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h1><h2 id="2-1-两个数组"><a href="#2-1-两个数组" class="headerlink" title="2.1 两个数组"></a>2.1 两个数组</h2><p>为了实现 nextTick，Vue中维护了2个数组：</p><ul><li>queue</li><li>callbacks</li></ul><h6 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h6><p>存放 wacther（去重），，当执行DOM更新的函数时，会遍历 queue 的元素 通知 watcher 去更新渲染</p><h6 id="callbacks"><a href="#callbacks" class="headerlink" title="callbacks"></a>callbacks</h6><p>存放回调函数(更新渲染任务、用户定义的逻辑)，当依次执行 callbacks 中维护的任务时，就可以保证用户<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong></p><p>先了解这两个数组，便于下面的原理分析</p><h2 id="2-2-修改数据时"><a href="#2-2-修改数据时" class="headerlink" title="2.2 修改数据时"></a>2.2 修改数据时</h2><p>当你设置 <code>vm.someData = &#39;new value&#39;</code></p><p>对应的依赖发生改变，Wacther会开始异步更新，调用 <code>queueWatcher()</code>函数</p><blockquote><p><code>queueWatcher()</code>函数源码位置：vue-main\src\core\observer\scheduler.ts</p></blockquote><p> <code>queueWatcher()</code>函数</p><p>首先判断 <code>queue</code> 数组中是否存在该 watcher ，如果不存在就会将当前 watcher 推入 <code>queue</code> 中，实现去重</p><blockquote><p>那么为什么要实现去重？</p><p>因为用户在一个组件中可能多次修改数据，<code>vm.someData = &#39;new value1&#39;， vm.someData = &#39;new value22&#39;</code></p><p>它不需要存放相同的 watcher，只需维护一个，等待 watcher 更新时会渲染最新的数据</p></blockquote><p>然后会调用 <code>nextTick()</code> 函数，并将回调函数 <code>flushSchedulerQueue()</code> 作为参数传入</p><p>总结一下：</p><ul><li>去重，watcher 推入 queue</li><li>调用 <code>nextTick()</code> 函数，并传入回调函数</li></ul><p>下面我们可以看看源代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with duplicate IDs will be skipped unless it&#x27;s</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueWatcher</span>(<span class="params">watcher: Watcher</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (watcher === <span class="title class_">Dep</span>.<span class="property">target</span> &amp;&amp; watcher.<span class="property">noRecurse</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  has[id] = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">    queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">    <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">    <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// queue the flush</span></span><br><span class="line">  <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">    waiting = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !config.<span class="property">async</span>) &#123;</span><br><span class="line">      <span class="title function_">flushSchedulerQueue</span>()</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-flushSchedulerQueue-函数做什么"><a href="#2-3-flushSchedulerQueue-函数做什么" class="headerlink" title="2.3 flushSchedulerQueue() 函数做什么"></a>2.3 flushSchedulerQueue() 函数做什么</h2><p><code>flushSchedulerQueue()</code> 函数遍历 queue ，通知对应的 watcher 去渲染更新</p><p>首先调用 watcher.run()  </p><p>run()内部则 watcher.get()</p><p>会调用 渲染更新方法</p><blockquote><p>这里涉及的 watcher 在后面的文章会提到</p></blockquote><div align="center">    <img src="/2023/07/08/Vue2源码：nextTick原理/流程.png" style="height: 270px; width: 700px;"></div><h2 id="2-4-nextTick-函数"><a href="#2-4-nextTick-函数" class="headerlink" title="2.4 nextTick() 函数"></a>2.4 nextTick() 函数</h2><blockquote><p>源码位置：vue-main\src\core\util\next-tick.ts</p></blockquote><p>进入该函数后，这时候第二个数组也用到了</p><p>它会将<strong>回调函数推入callbacks</strong>中，当前callbacks数组状态： [ flushSchedulerQueue() ]</p><p>然后调用 <code>timerFunc() </code> 函数，<strong>这个函数会依次执行 <code>callbacks</code> 中的回调函数</strong></p><p>但是 <code>timerFunc() </code> 函数能随随便便的执行吗？</p><p>不行</p><p>我们要 保证执行一个事件循环中只执行一次  <code>timerFunc() </code> ，就需要加上<strong>锁机制：pending变量</strong></p><p>变量 <code>pending</code> 设置布尔值，用来保证执行一个事件循环中只执行一次 <code>timerFunc()</code>函数。</p><p>如果 <code>timerFunc()</code> 函数执行后，才会改变 <code>pending</code> 值</p><p>看看源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">nextTick</span>(<span class="params">cb?: (...args: any[]) =&gt; any, ctx?: object</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.<span class="title function_">call</span>(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (<span class="attr">e</span>: any) &#123;</span><br><span class="line">        <span class="title function_">handleError</span>(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      <span class="title function_">_resolve</span>(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">timerFunc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-timerFunc-函数"><a href="#2-5-timerFunc-函数" class="headerlink" title="2.5 timerFunc() 函数"></a>2.5 timerFunc() 函数</h2><p>考虑兼容性，<code>timerFunc()</code> 内部以优雅降级的方式执行回调函数</p><ul><li>内部先采用的是 promise（ie不兼容）  </li><li>不兼容则使用 MutationObserver(h5的api)  </li><li>否则可以考虑ie专享的 setImmediate  </li><li>或者 setTimeout</li></ul><p>执行时调用 <code>flushCallbacks(</code>) 函数，去遍历 callbacks 执行回调函数</p><p>看看源码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(<span class="title class_">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.<span class="title function_">then</span>(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  !isIE &amp;&amp;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="title class_">MutationObserver</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp;</span><br><span class="line">  (<span class="title function_">isNative</span>(<span class="title class_">MutationObserver</span>) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    <span class="title class_">MutationObserver</span>.<span class="title function_">toString</span>() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="title class_">String</span>(counter))</span><br><span class="line">  observer.<span class="title function_">observe</span>(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.<span class="property">data</span> = <span class="title class_">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="title function_">isNative</span>(setImmediate)) &#123;</span><br><span class="line">  <span class="comment">// Fallback to setImmediate.</span></span><br><span class="line">  <span class="comment">// Technically it leverages the (macro) task queue,</span></span><br><span class="line">  <span class="comment">// but it is still a better choice than setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setImmediate</span>(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6-用户定义nextTick"><a href="#2-6-用户定义nextTick" class="headerlink" title="2.6 用户定义nextTick()"></a>2.6 用户定义nextTick()</h2><p>如果当前用户使用 <strong>vue 的 nextTick(</strong>)，传入自己的回调函数 <strong>myFn()</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.$nextTick( <span class="function">()=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Element</span>.<span class="property">innerHTML</span>)</span><br><span class="line">&#125; )</span><br></pre></td></tr></table></figure><p>内部执行**nextTick()**后</p><p>然后当前callbacks数组状态： [ flushSchedulerQueue(), myFn() ]</p><p>最后当执行 <code>timerFunc()</code> 函数时，遍历 callbacks ，执行对应的回调函数</p><p>实现：<strong>基于更新后的 DOM 状态来执行自己的逻辑</strong></p><h1 id="3-流程图"><a href="#3-流程图" class="headerlink" title="3 流程图"></a>3 流程图</h1><div align="center">    <img src="/2023/07/08/Vue2源码：nextTick原理/main.png" style="height: 500px; width: 600px;"></div>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>渲染性能优化：懒加载-异步解码</title>
      <link href="/2023/07/06/%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD-%E5%BC%82%E6%AD%A5%E8%A7%A3%E7%A0%81/"/>
      <url>/2023/07/06/%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E6%87%92%E5%8A%A0%E8%BD%BD-%E5%BC%82%E6%AD%A5%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>懒加载是一种网页性能优化的常见方式，它能极大的提升用户体验。到今天，一个网站里面可能会有几百张甚至几千张上万张图片和其他资源，如果每次进入页面都需要请求页面上的所有的资源，会较大的影响用户体验，对用户的带宽也是一种极大的损耗。</p><p>所以，懒加载的意义即是，<strong>当页面未滚动到相应区域，该区域内的资源（网络请求）不会被加载。反之，当页面滚动到相应区域，相关资源的请求才会被发起。</strong></p><p>之前，图片的懒加载通常都是使用 JavaScript 方案进行：</p><blockquote><p>先给页面的图片设置一个占位符，不要把图片真实地址放在src中，真正的路径存储在一个属性中，要用的时候再取出来，页面加载完成后，判断图片是否在用户视野，如果在，就把值取出放入src属性；</p><p>如果 offsetTop - scrollTop &lt; clientHeight，说明图片出现在可视区域</p></blockquote><p>而今天，我们在懒加载实现上，有了更多不一样的选择。下面会介绍两种方式并进行测验:</p><ul><li>content-visibility: auto</li><li>loading&#x3D;”lazy” 和 decoding&#x3D;”async”</li></ul><h1 id="1-使用-content-visibility-实现延迟渲染"><a href="#1-使用-content-visibility-实现延迟渲染" class="headerlink" title="1 使用 content-visibility 实现延迟渲染"></a>1 使用 content-visibility 实现延迟渲染</h1><h2 id="1-1-What"><a href="#1-1-What" class="headerlink" title="1.1 What"></a>1.1 What</h2><p> <code>content-visibility： auto</code></p><p>其控制一个元素，直到需要它的时候才会渲染</p><p>利用 content-visibility ，我们可以实现如果该元素当前不在屏幕上，则不会渲染其后代元素。</p><h2 id="1-2-Demo"><a href="#1-2-Demo" class="headerlink" title="1.2 Demo"></a>1.2 Demo</h2><p>如果有如下页面结构，我使用 items 数组存放15个照片，都是通过网络请求拿到的，模板中进行渲染</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-<span class="keyword">for</span>=<span class="string">&quot;item in items&quot;</span> :key=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container-box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>-------------&#123;&#123; item.id &#125;&#125;-------------<span class="tag">&lt;/<span class="name">p</span>&gt;</span>   </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="attr">items</span>: [&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">0</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://b.hiphotos.baidu.com/image/pic/item/9d82d158ccbf6c81b94575cfb93eb13533fa40a2.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;,&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">1</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;https://gtd.alicdn.com/sns_logo/i3/TB1wnBTKFXXXXcQXXXXSutbFXXX.jpg_240x240xz.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">2</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;//www.baidu.com/img/flexible/logo/pc/result.png&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">3</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/a1ec08fa513d2697e542494057fbb2fb4316d81e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">4</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://c.hiphotos.baidu.com/image/pic/item/30adcbef76094b36de8a2fe5a1cc7cd98d109d99.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">5</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://h.hiphotos.baidu.com/image/pic/item/7c1ed21b0ef41bd5f2c2a9e953da81cb39db3d1d.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">6</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/55e736d12f2eb938d5277fd5d0628535e5dd6f4a.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">7</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4e4a20a4462309f7e41f5cfe760e0cf3d6cad6ee.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">8</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/6d81800a19d8bc3e770bd00d868ba61ea9d345f2.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">9</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://e.hiphotos.baidu.com/image/pic/item/4bed2e738bd4b31c1badd5a685d6277f9e2ff81e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">10</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://g.hiphotos.baidu.com/image/pic/item/0d338744ebf81a4c87a3add4d52a6059252da61e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">11</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://a.hiphotos.baidu.com/image/pic/item/f2deb48f8c5494ee5080c8142ff5e0fe99257e19.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">12</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://f.hiphotos.baidu.com/image/pic/item/4034970a304e251f503521f5a586c9177e3e53f9.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">13</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://b.hiphotos.baidu.com/image/pic/item/279759ee3d6d55fbb3586c0168224f4a20a4dd7e.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;, &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">id</span>: <span class="number">14</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">src</span>: <span class="string">&quot;http://a.hiphotos.baidu.com/image/pic/item/e824b899a9014c087eb617650e7b02087af4f464.jpg&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>页面看起来是这样的：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/contentVisibility.png" style="height: 500px; width: 500px;"></div><p>只需要给需要延迟（实时）渲染的元素，设置简单的 CSS 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-box</span> &#123;</span><br><span class="line">  <span class="attribute">content-visibility</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以实现延迟加载了</p><h2 id="1-3-可访问性"><a href="#1-3-可访问性" class="headerlink" title="1.3 可访问性"></a>1.3 可访问性</h2><p>全文检索是一个重要的功能</p><p>如果说可视区外的内容未被渲染，那是否会影响用户进行全文检索呢？</p><p>在页面初始化后，我全局 <code>ctrl + F</code>，搜索 7 ，全局查找的时候，可以找到当前未被渲染的元素内的内容</p><p>因此，<strong>即便存在设置了 <code>content-visibility: auto</code> 的未被渲染的元素，但是它并不会影响全局的搜索功能</strong>。</p><h2 id="1-4-But"><a href="#1-4-But" class="headerlink" title="1.4 But"></a>1.4 But</h2><p>文章还没到一半，当然不会就这么结束了</p><p>因为有2个<strong>缺点</strong>：</p><ul><li><strong>滚动条在向下滚动在不断的抖动：</strong>这是由于下面不在可视区域内的内容，一开始是没有被渲染的，在每次滚动的过程中，才逐渐渲染导致滚动条抽搐，用户体验挺差的</li></ul><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/contentVisibility.webp" style="height: 500px; width: 500px;"></div><ul><li><strong>初始化时请求全部发送了：</strong>即便当前页面可视区域外的内容未被渲染，但是图片资源的 HTTP&#x2F;HTTPS 请求，依然会在页面一开始被触发</li></ul><h3 id="1-3-1-利用-contain-intrinsic-size-解决滚动条抖动问题"><a href="#1-3-1-利用-contain-intrinsic-size-解决滚动条抖动问题" class="headerlink" title="1.3.1 利用 contain-intrinsic-size 解决滚动条抖动问题"></a>1.3.1 利用 contain-intrinsic-size 解决滚动条抖动问题</h3><p>当我们使用 <code>content-visibility: auto</code>，那么可视区外的元素高度通常就为 0，当滚动条移动，元素展示，所以会出现抖动抽搐。</p><p>如果能准确知道设置了<strong>元素在渲染状态下的高度</strong>，就可以避免抖动现象了。</p><p>因此我为元素加上 contain-intrinsic-size 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container-box</span> &#123;</span><br><span class="line">  <span class="attribute">contain</span>-intrinsic-size: <span class="number">320px</span>;</span><br><span class="line">  <span class="attribute">content-visibility</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/解决抖动.webp" style="height: 500px; width: 500px;"></div><p><strong>所以，content-visibility: auto 无法完全替代图片懒加载，设置了 content-visibility: auto 的确实现了延迟渲染，但是其中的静态资源仍旧会在页面初始化的时候被全部加载。因此，它更适合于虚拟列表渲染的情景。</strong></p><h1 id="2-懒加载-异步解码"><a href="#2-懒加载-异步解码" class="headerlink" title="2 懒加载+异步解码"></a>2 懒加载+异步解码</h1><h2 id="2-1-懒加载-loading-x3D-”lazy”"><a href="#2-1-懒加载-loading-x3D-”lazy”" class="headerlink" title="2.1 懒加载 loading&#x3D;”lazy”"></a>2.1 懒加载 loading&#x3D;”lazy”</h2><p>HTML5 新增了一个 loading 属性。此属性可以添加到 &lt; img &gt; 元素中，也可以添加到 &lt; iframe &gt; 元素中。</p><p>属性的值为 loading&#x3D;”lazy” 会告诉浏览器，如果图像位于可视区时，则立即加载图像，并在用户滚动到它们附近时获取其他图像。</p><p>loading&#x3D;”lazy” 到（2023-07-08）的兼容性，还是非常不错的：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/loading兼容.png" style="height: 300px; width: 900px;"></div><h2 id="2-2-异步解码-decoding-x3D-”async”"><a href="#2-2-异步解码-decoding-x3D-”async”" class="headerlink" title="2.2 异步解码 decoding&#x3D;”async”"></a>2.2 异步解码 decoding&#x3D;”async”</h2><p><code>HTMLImageElement</code> 接口的 <code>decoding</code> 属性用于告诉浏览器使用何种方式解析图像数据。</p><ul><li>sync: 同步解码图像，保证与其他内容一起显示。</li><li>async: 异步解码图像，加快显示其他内容。</li><li>auto: 默认模式，表示不偏好解码模式。由浏览器决定哪种方式更适合用户。</li></ul><p>浏览器在进行图片渲染展示的过程中，是需要对图片文件进行解码的，这一个过程快慢与图片格式有关。</p><p>而如果我们不希望图片的渲染解码影响页面的其他内容的展示，可以使用 async 选项</p><p>这样，浏览器便会异步解码图像，加快显示其他内容，优化页面渲染性能。</p><p>同样的，我们来看看到（2023-07-08），decoding&#x3D;”async” 的兼容性，整体还是非常不错的，作为渐进增强方案使用，是非常好的选择。</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/decoding兼容.png" style="height: 300px; width: 900px;"></div><h2 id="2-3-Demo"><a href="#2-3-Demo" class="headerlink" title="2.3 Demo"></a>2.3 Demo</h2><p>和上面的Demo差不多，准备14张图片的页面，每个图片url大小不一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;!-- loading=&quot;lazy&quot; 懒加载 --&gt;</span><br><span class="line">    &lt;div v-for=&quot;item in items&quot; :key=&quot;item&quot;&gt;</span><br><span class="line">      &lt;div class=&quot;container-box2&quot;&gt;</span><br><span class="line">        &lt;p&gt;-------------&#123;&#123; item.id &#125;&#125;-------------&lt;/p&gt;   </span><br><span class="line">        &lt;img :src=&quot;item.src&quot; alt=&quot;&quot; loading=&quot;lazy&quot; decoding=&quot;async&quot;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      items: [&#123;</span><br><span class="line">        id: 0,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/6d81800a19d8bc3e770bd00d868ba61ea9d345f2.jpg&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        src: &quot;https://gtd.alicdn.com/sns_logo/i3/TB1wnBTKFXXXXcQXXXXSutbFXXX.jpg_240x240xz.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        src: &quot;//www.baidu.com/img/flexible/logo/pc/result.png&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 3,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/a1ec08fa513d2697e542494057fbb2fb4316d81e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 4,</span><br><span class="line">        src: &quot;http://c.hiphotos.baidu.com/image/pic/item/30adcbef76094b36de8a2fe5a1cc7cd98d109d99.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 5,</span><br><span class="line">        src: &quot;http://h.hiphotos.baidu.com/image/pic/item/7c1ed21b0ef41bd5f2c2a9e953da81cb39db3d1d.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 6,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/55e736d12f2eb938d5277fd5d0628535e5dd6f4a.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 7,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/4e4a20a4462309f7e41f5cfe760e0cf3d6cad6ee.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 8,</span><br><span class="line">        src: &quot;http://b.hiphotos.baidu.com/image/pic/item/9d82d158ccbf6c81b94575cfb93eb13533fa40a2.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 9,</span><br><span class="line">        src: &quot;http://e.hiphotos.baidu.com/image/pic/item/4bed2e738bd4b31c1badd5a685d6277f9e2ff81e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 10,</span><br><span class="line">        src: &quot;http://g.hiphotos.baidu.com/image/pic/item/0d338744ebf81a4c87a3add4d52a6059252da61e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 11,</span><br><span class="line">        src: &quot;http://a.hiphotos.baidu.com/image/pic/item/f2deb48f8c5494ee5080c8142ff5e0fe99257e19.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 12,</span><br><span class="line">        src: &quot;http://f.hiphotos.baidu.com/image/pic/item/4034970a304e251f503521f5a586c9177e3e53f9.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 13,</span><br><span class="line">        src: &quot;http://b.hiphotos.baidu.com/image/pic/item/279759ee3d6d55fbb3586c0168224f4a20a4dd7e.jpg&quot;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 14,</span><br><span class="line">        src: &quot;http://a.hiphotos.baidu.com/image/pic/item/e824b899a9014c087eb617650e7b02087af4f464.jpg&quot;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>由于是纯图片页面，需要给给图片设置默认宽高。</p><p>否则初次刷新时，元素的宽高都是 0，会导致所有元素都在可视区内。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">8px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">202px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">166px</span>;</span><br><span class="line">    <span class="attribute">object-fit</span>: cover; <span class="comment">/* 居中自动剪裁图片 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>效果：</p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/懒加载.webp" style="height: 500px; width: 500px;"></div><p>可以看到，初次加载时，只会请求当前页面的资源，随着可视区域变化，再进行资源请求</p><h2 id="2-4-性能测试"><a href="#2-4-性能测试" class="headerlink" title="2.4 性能测试"></a>2.4 性能测试</h2><p>为了验证性能，在上面的Demo基础上，进行对比测试。</p><p>首先是没有添加懒加载的元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，初次页面加载时会请求所有资源，<strong>页面 Load 事件完成的时间竟然有 14.96 s</strong></p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/对比实验1.png" style="height: 130px; width: 800px;"></div><p>现在我们为他加上 loading&#x3D;”lazy” 与 decoding&#x3D;async”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;item.src&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">loading</span>=<span class="string">&quot;lazy&quot;</span> <span class="attr">decoding</span>=<span class="string">&quot;async&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>首次进入页面仅请求显示在屏幕上的图片，<strong>页面 Load 事件完成的时间为 597 ms</strong></p><div align="center">    <img src="/2023/07/06/渲染性能优化：懒加载-异步解码/对比实验2.png" style="height: 130px; width: 800px;"></div><p>当页面滚动时，显示的图片才会继续发送请求</p><h1 id="3-总结一下"><a href="#3-总结一下" class="headerlink" title="3 总结一下"></a>3 总结一下</h1><ul><li>content-visibility: auto + contain-intrinsic-size 可以实现延迟渲染，并且不会影响全局的搜索功能<ul><li>但是初始化时，资源会全部加载，因此不太适合做图片懒加载，更适合于虚拟列表场景</li></ul></li><li>loading&#x3D;”lazy” + decoding&#x3D;”async” 可以实现懒加载+异步解码，浏览器只会加载可视区的资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
